# Resources to be used as redirect destinations.
#
# - Each distinct resource entry is separated by an empty line.
# - The first line in a resource entry is: token mime-type[;encoding]
# - Optional aliases may follow, one per line: alias alternativetoken
# - All following lines are the data. An empty line signals the end of the
#   data.
#
# Mind that application/javascript scriptlet resources' names/aliases always end with: .js
#
# If the encoding is absent, the data will be converted to base64, and the
# encoding will be set to `;base64`.
#
# Put comments only before metadata or after the line signaling the end of data.


# http://probablyprogramming.com/2009/03/15/the-tiniest-gif-ever
1x1.gif image/gif;base64
alias 1x1-transparent.gif
R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==


2x2.png image/png;base64
alias 2x2-transparent.png
iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAC0lEQVQI12NgQAcAABIAAe+JVKQAAAAA
SUVORK5CYII=


3x2.png image/png;base64
alias 3x2-transparent.png
iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAYAAACddGYaAAAAC0lEQVQI12NgwAUAABoAASRETuUAAAAA
SUVORK5CYII=


32x32.png image/png;base64
alias 32x32-transparent.png
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGklEQVRYw+3BAQEAAACCIP+vbkhAAQAA
AO8GECAAAZf3V9cAAAAASUVORK5CYII=


noop.txt text/plain
alias nooptext


noop.css text/css
alias noopcss


noop-vmap1.0.xml text/xml
alias noopvmap-1.0
<vmap:VMAP xmlns:vmap="http://www.iab.net/videosuite/vmap" version="1.0"></vmap:VMAP>


noop.js application/javascript
alias noopjs
alias abp-resource:blank-js
(function() {
	;
})();


noop.json application/json
alias noopjson
{}


noop.html text/html
alias noopframe
<!DOCTYPE html>
<html>
	<head><title></title></head>
	<body></body>
</html>


# From:
#   https://ubuntuforums.org/showthread.php?t=1911430&p=11624471#post11624471
# ffmpeg -ar 48000 -t 0.1 -f s16le -acodec pcm_s16le -ac 2 -i /dev/zero -acodec libmp3lame -aq 4 output.mp3
# But with 0.1 (second) instead of 60.
noop-0.1s.mp3 audio/mp3;base64
alias noopmp3-0.1s
alias abp-resource:blank-mp3
SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU2LjQwLjEwMQAAAAAAAAAAAAAA//tUAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAGAAADAABgYGBgYGBgYGBgYGBgYGBggICAgICA
gICAgICAgICAgICgoKCgoKCgoKCgoKCgoKCgwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODg4ODg4ODg4ODg
4P////////////////////8AAAAATGF2YzU2LjYwAAAAAAAAAAAAAAAAJAAAAAAAAAAAAwDNZKlY//sU
ZAAP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAETEFNRTMuOTkuNVVVVVVVVVVVVVVVVVVVVVVV
VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sUZB4P8AAAaQAAAAgAAA0gAAABAAABpAAA
ACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
VVVVVVVVVVVV//sUZDwP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVV
VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sUZFoP8AAAaQAAAAgA
AA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
VVVVVVVVVVVVVVVVVVVVVVVVVVVV//sUZHgP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVV
VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sU
ZJYP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV

# From:
#   https://github.com/kud/blank-video
noop-1s.mp4 video/mp4;base64
alias noopmp4-1s
alias abp-resource:blank-mp4
AAAAHGZ0eXBNNFYgAAACAGlzb21pc28yYXZjMQAAAAhmcmVlAAAGF21kYXTeBAAAbGliZmFhYyAxLjI4
AABCAJMgBDIARwAAArEGBf//rdxF6b3m2Ui3lizYINkj7u94MjY0IC0gY29yZSAxNDIgcjIgOTU2Yzhk
OCAtIEguMjY0L01QRUctNCBBVkMgY29kZWMgLSBDb3B5bGVmdCAyMDAzLTIwMTQgLSBodHRwOi8vd3d3
LnZpZGVvbGFuLm9yZy94MjY0Lmh0bWwgLSBvcHRpb25zOiBjYWJhYz0wIHJlZj0zIGRlYmxvY2s9MTow
OjAgYW5hbHlzZT0weDE6MHgxMTEgbWU9aGV4IHN1Ym1lPTcgcHN5PTEgcHN5X3JkPTEuMDA6MC4wMCBt
aXhlZF9yZWY9MSBtZV9yYW5nZT0xNiBjaHJvbWFfbWU9MSB0cmVsbGlzPTEgOHg4ZGN0PTAgY3FtPTAg
ZGVhZHpvbmU9MjEsMTEgZmFzdF9wc2tpcD0xIGNocm9tYV9xcF9vZmZzZXQ9LTIgdGhyZWFkcz02IGxv
b2thaGVhZF90aHJlYWRzPTEgc2xpY2VkX3RocmVhZHM9MCBucj0wIGRlY2ltYXRlPTEgaW50ZXJsYWNl
ZD0wIGJsdXJheV9jb21wYXQ9MCBjb25zdHJhaW5lZF9pbnRyYT0wIGJmcmFtZXM9MCB3ZWlnaHRwPTAg
a2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29r
YWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02
OSBxcHN0ZXA9NCB2YnZfbWF4cmF0ZT03NjggdmJ2X2J1ZnNpemU9MzAwMCBjcmZfbWF4PTAuMCBuYWxf
aHJkPW5vbmUgZmlsbGVyPTAgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAAFZliIQL8mKAAKvMnJyc
nJycnJycnXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXiEASZACGQAjgCEASZACGQAjgAAAAAdBmjgX4GSAIQBJkAIZACOAAAAAB0GaVAX4
GSAhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGagC/AySEA
SZACGQAjgAAAAAZBmqAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZrAL8DJIQBJkAIZACOAAAAABkGa
4C/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmwAvwMkhAEmQAhkAI4AAAAAGQZsgL8DJIQBJkAIZACOA
IQBJkAIZACOAAAAABkGbQC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm2AvwMkhAEmQAhkAI4AAAAAG
QZuAL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGboC/AySEASZACGQAjgAAAAAZBm8AvwMkhAEmQAhkA
I4AhAEmQAhkAI4AAAAAGQZvgL8DJIQBJkAIZACOAAAAABkGaAC/AySEASZACGQAjgCEASZACGQAjgAAA
AAZBmiAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpAL8DJIQBJkAIZACOAAAAABkGaYC/AySEASZAC
GQAjgCEASZACGQAjgAAAAAZBmoAvwMkhAEmQAhkAI4AAAAAGQZqgL8DJIQBJkAIZACOAIQBJkAIZACOA
AAAABkGawC/AySEASZACGQAjgAAAAAZBmuAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZsAL8DJIQBJ
kAIZACOAAAAABkGbIC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm0AvwMkhAEmQAhkAI4AhAEmQAhkA
I4AAAAAGQZtgL8DJIQBJkAIZACOAAAAABkGbgCvAySEASZACGQAjgCEASZACGQAjgAAAAAZBm6AnwMkh
AEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AAAAhubW9vdgAAAGxtdmhkAAAAAAAAAAAA
AAAAAAAD6AAABDcAAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAzB0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAA
AAABAAAAAAAAA+kAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABA
AAAAALAAAACQAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAPpAAAAAAABAAAAAAKobWRpYQAAACBt
ZGhkAAAAAAAAAAAAAAAAAAB1MAAAdU5VxAAAAAAALWhkbHIAAAAAAAAAAHZpZGUAAAAAAAAAAAAAAABW
aWRlb0hhbmRsZXIAAAACU21pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAA
AAAAAQAAAAx1cmwgAAAAAQAAAhNzdGJsAAAAr3N0c2QAAAAAAAAAAQAAAJ9hdmMxAAAAAAAAAAEAAAAA
AAAAAAAAAAAAAAAAALAAkABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAGP//AAAALWF2Y0MBQsAN/+EAFWdCwA3ZAsTsBEAAAPpAADqYA8UKkgEABWjLg8sgAAAAHHV1aWRr
aEDyXyRPxbo5pRvPAyPzAAAAAAAAABhzdHRzAAAAAAAAAAEAAAAeAAAD6QAAABRzdHNzAAAAAAAAAAEA
AAABAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAABAAAAAQAAAIxzdHN6AAAAAAAAAAAAAAAeAAADDwAAAAsA
AAALAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoA
AAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAAiHN0Y28A
AAAAAAAAHgAAAEYAAANnAAADewAAA5gAAAO0AAADxwAAA+MAAAP2AAAEEgAABCUAAARBAAAEXQAABHAA
AASMAAAEnwAABLsAAATOAAAE6gAABQYAAAUZAAAFNQAABUgAAAVkAAAFdwAABZMAAAWmAAAFwgAABd4A
AAXxAAAGDQAABGh0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAACAAAAAAAABDcAAAAAAAAAAAAAAAEB
AAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAkZWR0cwAAABxl
bHN0AAAAAAAAAAEAAAQkAAADcAABAAAAAAPgbWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAC7gAAAykBV
xAAAAAAALWhkbHIAAAAAAAAAAHNvdW4AAAAAAAAAAAAAAABTb3VuZEhhbmRsZXIAAAADi21pbmYAAAAQ
c21oZAAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAADT3N0YmwAAABn
c3RzZAAAAAAAAAABAAAAV21wNGEAAAAAAAAAAQAAAAAAAAAAAAIAEAAAAAC7gAAAAAAAM2VzZHMAAAAA
A4CAgCIAAgAEgICAFEAVBbjYAAu4AAAADcoFgICAAhGQBoCAgAECAAAAIHN0dHMAAAAAAAAAAgAAADIA
AAQAAAAAAQAAAkAAAAFUc3RzYwAAAAAAAAAbAAAAAQAAAAEAAAABAAAAAgAAAAIAAAABAAAAAwAAAAEA
AAABAAAABAAAAAIAAAABAAAABgAAAAEAAAABAAAABwAAAAIAAAABAAAACAAAAAEAAAABAAAACQAAAAIA
AAABAAAACgAAAAEAAAABAAAACwAAAAIAAAABAAAADQAAAAEAAAABAAAADgAAAAIAAAABAAAADwAAAAEA
AAABAAAAEAAAAAIAAAABAAAAEQAAAAEAAAABAAAAEgAAAAIAAAABAAAAFAAAAAEAAAABAAAAFQAAAAIA
AAABAAAAFgAAAAEAAAABAAAAFwAAAAIAAAABAAAAGAAAAAEAAAABAAAAGQAAAAIAAAABAAAAGgAAAAEA
AAABAAAAGwAAAAIAAAABAAAAHQAAAAEAAAABAAAAHgAAAAIAAAABAAAAHwAAAAQAAAABAAAA4HN0c3oA
AAAAAAAAAAAAADMAAAAaAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkA
AAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkA
AAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkA
AAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAACMc3RjbwAAAAAAAAAfAAAALAAAA1UA
AANyAAADhgAAA6IAAAO+AAAD0QAAA+0AAAQAAAAEHAAABC8AAARLAAAEZwAABHoAAASWAAAEqQAABMUA
AATYAAAE9AAABRAAAAUjAAAFPwAABVIAAAVuAAAFgQAABZ0AAAWwAAAFzAAABegAAAX7AAAGFwAAAGJ1
ZHRhAAAAWm1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAALWlsc3QAAAAl
qXRvbwAAAB1kYXRhAAAAAQAAAABMYXZmNTUuMzMuMTAw


hd-main.js application/javascript
(function() {
	'use strict';
	const l = {};
	const noopfn = function() {
	};
	const props = [
		"$j","Ad","Bd","Cd","Dd","Ed","Fd","Gd","Hd","Id","Jd","Nj","Oc","Pc","Pe",
		"Qc","Qe","Rc","Re","Ri","Sc","Tc","Uc","Vc","Wc","Wg","Xc","Xg","Yc","Yd",
		"ad","ae","bd","bf","cd","dd","ed","ef","ek","fd","fg","fh","fk","gd","hd",
		"ig","ij","jd","kd","ke","ld","md","mi","nd","od","oh","pd","pf","qd","rd",
		"sd","td","ud","vd","wd","wg","xd","xh","yd","zd",
		"$d","$e","$k","Ae","Af","Aj","Be","Ce","De","Ee","Ek","Eo","Ep","Fe","Fo",
		"Ge","Gh","Hk","Ie","Ip","Je","Ke","Kk","Kq","Le","Lh","Lk","Me","Mm","Ne",
		"Oe","Pe","Qe","Re","Rp","Se","Te","Ue","Ve","Vp","We","Xd","Xe","Yd","Ye",
		"Zd","Ze","Zf","Zk","ae","af","al","be","bf","bg","ce","cp","df","di","ee",
		"ef","fe","ff","gf","gm","he","hf","ie","je","jf","ke","kf","kl","le","lf",
		"lk","mf","mg","mn","nf","oe","of","pe","pf","pg","qe","qf","re","rf","se",
		"sf","te","tf","ti","ue","uf","ve","vf","we","wf","wg","wi","xe","ye","yf",
		"yk","yl","ze","zf","zk"
	];
	for ( let i = 0; i < props.length; i++ ) {
		l[props[i]] = noopfn;
	}
	window.L = window.J = l;
})();


# fuckadblock defuser
nofab.js application/javascript
alias fuckadblock.js-3.2.0
(function() {
	'use strict';
	const noopfn = function() {
	};
	const Fab = function() {};
	Fab.prototype.check = noopfn;
	Fab.prototype.clearEvent = noopfn;
	Fab.prototype.emitEvent = noopfn;
	Fab.prototype.on = function(a, b) {
		if ( !a ) { b(); }
		return this;
	};
	Fab.prototype.onDetected = function() {
		return this;
	};
	Fab.prototype.onNotDetected = function(a) {
		a();
		return this;
	};
	Fab.prototype.setOption = noopfn;
	Fab.prototype.options = {
		set: noopfn,
		get: noopfn,
	};
	const fab = new Fab();
	const getSetFab = {
		get: function() { return Fab; },
		set: function() {}
	};
	const getsetfab = {
		get: function() { return fab; },
		set: function() {}
	};
	if ( window.hasOwnProperty('FuckAdBlock') ) { window.FuckAdBlock = Fab; }
	else { Object.defineProperty(window, 'FuckAdBlock', getSetFab); }
	if ( window.hasOwnProperty('BlockAdBlock') ) { window.BlockAdBlock = Fab; }
	else { Object.defineProperty(window, 'BlockAdBlock', getSetFab); }
	if ( window.hasOwnProperty('SniffAdBlock') ) { window.SniffAdBlock = Fab; }
	else { Object.defineProperty(window, 'SniffAdBlock', getSetFab); }
	if ( window.hasOwnProperty('fuckAdBlock') ) { window.fuckAdBlock = fab; }
	else { Object.defineProperty(window, 'fuckAdBlock', getsetfab); }
	if ( window.hasOwnProperty('blockAdBlock') ) { window.blockAdBlock = fab; }
	else { Object.defineProperty(window, 'blockAdBlock', getsetfab); }
	if ( window.hasOwnProperty('sniffAdBlock') ) { window.sniffAdBlock = fab; }
	else { Object.defineProperty(window, 'sniffAdBlock', getsetfab); }
})();


# To neutralize GA scripts. The goal is to provide the minimal API
# expected by clients of these scripts so that the end users are able
# to wholly block GA while minimizing risks of page breakage.
# Test cases (need way more):
# - https://github.com/chrisaljoudi/uBlock/issues/119
# Reference API:
# - https://developers.google.com/analytics/devguides/collection/gajs/
google-analytics_ga.js application/javascript
alias google-analytics.com/ga.js
(function() {
	'use strict';
	const noopfn = function() {
	};
	//
	const Gaq = function() {
	};
	Gaq.prototype.Na = noopfn;
	Gaq.prototype.O = noopfn;
	Gaq.prototype.Sa = noopfn;
	Gaq.prototype.Ta = noopfn;
	Gaq.prototype.Va = noopfn;
	Gaq.prototype._createAsyncTracker = noopfn;
	Gaq.prototype._getAsyncTracker = noopfn;
	Gaq.prototype._getPlugin = noopfn;
	Gaq.prototype.push = function(a) {
		if ( typeof a === 'function' ) {
			a(); return;
		}
		if ( Array.isArray(a) === false ) { return; }
		// https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiDomainDirectory#_gat.GA_Tracker_._link
		// https://github.com/uBlockOrigin/uBlock-issues/issues/1807
		if (
			typeof a[0] === 'string' &&
			/(^|\.)_link$/.test(a[0]) &&
			typeof a[1] === 'string'
		) {
			try {
				window.location.assign(a[1]);
			} catch(ex) {
			}
		}
		// https://github.com/gorhill/uBlock/issues/2162
		if ( a[0] === '_set' && a[1] === 'hitCallback' && typeof a[2] === 'function' ) {
			a[2]();
		}
	};
	//
	const tracker = (function() {
		const out = {};
		const api = [
			'_addIgnoredOrganic _addIgnoredRef _addItem _addOrganic',
			'_addTrans _clearIgnoredOrganic _clearIgnoredRef _clearOrganic',
			'_cookiePathCopy _deleteCustomVar _getName _setAccount',
			'_getAccount _getClientInfo _getDetectFlash _getDetectTitle',
			'_getLinkerUrl _getLocalGifPath _getServiceMode _getVersion',
			'_getVisitorCustomVar _initData _linkByPost',
			'_setAllowAnchor _setAllowHash _setAllowLinker _setCampContentKey',
			'_setCampMediumKey _setCampNameKey _setCampNOKey _setCampSourceKey',
			'_setCampTermKey _setCampaignCookieTimeout _setCampaignTrack _setClientInfo',
			'_setCookiePath _setCookiePersistence _setCookieTimeout _setCustomVar',
			'_setDetectFlash _setDetectTitle _setDomainName _setLocalGifPath',
			'_setLocalRemoteServerMode _setLocalServerMode _setReferrerOverride _setRemoteServerMode',
			'_setSampleRate _setSessionTimeout _setSiteSpeedSampleRate _setSessionCookieTimeout',
			'_setVar _setVisitorCookieTimeout _trackEvent _trackPageLoadTime',
			'_trackPageview _trackSocial _trackTiming _trackTrans',
			'_visitCode'
		].join(' ').split(/\s+/);
		for ( const method of api ) {
			out[method] = noopfn;
		}
		out._getLinkerUrl = function(a) {
			return a;
		};
		// https://github.com/AdguardTeam/Scriptlets/issues/154
		out._link = function(a) {
			if ( typeof a !== 'string' ) { return; }
			try {
				window.location.assign(a);
			} catch(ex) {
			}
		};
		return out;
	})();
	//
	const Gat = function() {
	};
	Gat.prototype._anonymizeIP = noopfn;
	Gat.prototype._createTracker = noopfn;
	Gat.prototype._forceSSL = noopfn;
	Gat.prototype._getPlugin = noopfn;
	Gat.prototype._getTracker = function() {
		return tracker;
	};
	Gat.prototype._getTrackerByName = function() {
		return tracker;
	};
	Gat.prototype._getTrackers = noopfn;
	Gat.prototype.aa = noopfn;
	Gat.prototype.ab = noopfn;
	Gat.prototype.hb = noopfn;
	Gat.prototype.la = noopfn;
	Gat.prototype.oa = noopfn;
	Gat.prototype.pa = noopfn;
	Gat.prototype.u = noopfn;
	const gat = new Gat();
	window._gat = gat;
	//
	const gaq = new Gaq();
	(function() {
		const aa = window._gaq || [];
		if ( Array.isArray(aa) ) {
			while ( aa[0] ) {
				gaq.push(aa.shift());
			}
		}
	})();
	window._gaq = gaq.qf = gaq;
})();

google-analytics_analytics.js application/javascript
alias google-analytics.com/analytics.js
alias googletagmanager_gtm.js
alias googletagmanager.com/gtm.js
(function() {
	'use strict';
	// https://developers.google.com/analytics/devguides/collection/analyticsjs/
	const noopfn = function() {
	};
	//
	const Tracker = function() {
	};
	const p = Tracker.prototype;
	p.get = noopfn;
	p.set = noopfn;
	p.send = noopfn;
	//
	const w = window;
	const gaName = w.GoogleAnalyticsObject || 'ga';
	const gaQueue = w[gaName];
	// https://github.com/uBlockOrigin/uAssets/pull/4115
	const ga = function() {
		const len = arguments.length;
		if ( len === 0 ) { return; }
		const args = Array.from(arguments);
		let fn;
		let a = args[len-1];
		if ( a instanceof Object && a.hitCallback instanceof Function ) {
			fn = a.hitCallback;
		} else if ( a instanceof Function ) {
			fn = ( ) => { a(ga.create()); };
		} else {
			const pos = args.indexOf('hitCallback');
			if ( pos !== -1 && args[pos+1] instanceof Function ) {
				fn = args[pos+1];
			}
		}
		if ( fn instanceof Function === false ) { return; }
		try {
			fn();
		} catch (ex) {
		}
	};
	ga.create = function() {
		return new Tracker();
	};
	ga.getByName = function() {
		return new Tracker();
	};
	ga.getAll = function() {
		return [new Tracker()];
	};
	ga.remove = noopfn;
	// https://github.com/uBlockOrigin/uAssets/issues/2107
	ga.loaded = true;
	w[gaName] = ga;
	// https://github.com/gorhill/uBlock/issues/3075
	const dl = w.dataLayer;
	if ( dl instanceof Object ) {
		if ( dl.hide instanceof Object && typeof dl.hide.end === 'function' ) {
			dl.hide.end();
			dl.hide.end = ()=>{};
		}
		if ( typeof dl.push === 'function' ) {
			const doCallback = function(item) {
				if ( item instanceof Object === false ) { return; }
				if ( typeof item.eventCallback !== 'function' ) { return; }
				setTimeout(item.eventCallback, 1);
				item.eventCallback = ()=>{};
			};
			dl.push = new Proxy(dl.push, {
				apply: function(target, thisArg, args) {
					doCallback(args[0]);
					return Reflect.apply(target, thisArg, args);
				}
			});
			if ( Array.isArray(dl) ) {
				const q = dl.slice();
				for ( const item of q ) {
					doCallback(item);
				}
			}
		}
	}
	// empty ga queue
	if ( gaQueue instanceof Function && Array.isArray(gaQueue.q) ) {
		const q = gaQueue.q.slice();
		gaQueue.q.length = 0;
		for ( const entry of q ) {
			ga(...entry);
		}
	}
})();

google-analytics_inpage_linkid.js application/javascript
alias google-analytics.com/inpage_linkid.js
(function() {
	'use strict';
	window._gaq = window._gaq || {
		push: function() {
			;
		}
	};
})();

# https://github.com/gorhill/uBlock/issues/2480
# https://developers.google.com/analytics/devguides/collection/gajs/experiments#cxjs
google-analytics_cx_api.js application/javascript
alias google-analytics.com/cx/api.js
(function() {
	'use strict';
	const noopfn = function() {
	};
	window.cxApi = {
		chooseVariation: function() {
			return 0;
		},
		getChosenVariation: noopfn,
		setAllowHash: noopfn,
		setChosenVariation: noopfn,
		setCookiePath: noopfn,
		setDomainName: noopfn
		};
})();


# Source below is based on Mozilla source code:
# https://searchfox.org/mozilla-central/rev/d317e93d9a59c9e4c06ada85fbff9f6a1ceaaad1/browser/extensions/webcompat/shims/google-ima.js
# Modifications to the original code below this comment:
# - Avoid JS syntax not supported by older browser versions
# - Add missing shim event
# - Modified to avoid jshint warnings as per uBO's config
# - Added `OmidVerificationVendor` to `ima`
# - Have `AdError.getInnerError()` return `null`
# - Have `AdDisplayContainer` constructor add DIV element to container
# - Added missing event dispatcher functionality
# - Corrected return type of `Ad.getUniversalAdIds()`
# - Corrected typo in `UniversalAdIdInfo.getAdIdValue()` method name
# - Corrected dispatch of LOAD event when preloading is enabled
# - Corrected dispatch of CONTENT_PAUSE/RESUME_REQUESTED events
# Related issue:
# - https://github.com/uBlockOrigin/uBlock-issues/issues/2158
google-ima.js application/javascript
alias google-ima3
(function() {
	'use strict';
	if (!window.google || !window.google.ima || !window.google.ima.VERSION) {
		const VERSION = "3.517.2";
		const CheckCanAutoplay = (function() {
			// Sourced from: https://searchfox.org/mozilla-central/source/dom/media/gtest/negative_duration.mp4
			const TEST_VIDEO = new Blob(
				[
					new Uint32Array([
						469762048,
						1887007846,
						1752392036,
						0,
						913273705,
						1717987696,
						828601953,
						-1878917120,
						1987014509,
						1811939328,
						1684567661,
						0,
						0,
						0,
						-402456576,
						0,
						256,
						1,
						0,
						0,
						256,
						0,
						0,
						0,
						256,
						0,
						0,
						0,
						64,
						0,
						0,
						0,
						0,
						0,
						0,
						33554432,
						-201261056,
						1801548404,
						1744830464,
						1684564852,
						251658241,
						0,
						0,
						0,
						0,
						16777216,
						0,
						-1,
						-1,
						0,
						0,
						0,
						0,
						256,
						0,
						0,
						0,
						256,
						0,
						0,
						0,
						64,
						5,
						53250,
						-2080309248,
						1634296941,
						738197504,
						1684563053,
						1,
						0,
						0,
						0,
						0,
						-2137614336,
						-1,
						-1,
						50261,
						754974720,
						1919706216,
						0,
						0,
						1701079414,
						0,
						0,
						0,
						1701079382,
						1851869295,
						1919249508,
						16777216,
						1852402979,
						102,
						1752004116,
						100,
						1,
						0,
						0,
						1852400676,
						102,
						1701995548,
						102,
						0,
						1,
						1819440396,
						32,
						1,
						1651799011,
						108,
						1937011607,
						100,
						0,
						1,
						1668702599,
						49,
						0,
						1,
						0,
						0,
						0,
						33555712,
						4718800,
						4718592,
						0,
						65536,
						0,
						0,
						0,
						0,
						0,
						0,
						0,
						0,
						16776984,
						1630601216,
						21193590,
						-14745500,
						1729626337,
						-1407254428,
						89161945,
						1049019,
						9453056,
						-251611125,
						27269507,
						-379058688,
						-1329024392,
						268435456,
						1937011827,
						0,
						0,
						268435456,
						1668510835,
						0,
						0,
						335544320,
						2054386803,
						0,
						0,
						0,
						268435456,
						1868788851,
						0,
						0,
						671088640,
						2019915373,
						536870912,
						2019914356,
						0,
						16777216,
						16777216,
						0,
						0,
						0,
					]),
				],
				{ type: "video/mp4" }
			);
			let testVideo;
			return function() {
				if (!testVideo) {
					testVideo = document.createElement("video");
					testVideo.style =
						"position:absolute; width:0; height:0; left:0; right:0; z-index:-1; border:0";
					testVideo.setAttribute("muted", "muted");
					testVideo.setAttribute("playsinline", "playsinline");
					testVideo.src = URL.createObjectURL(TEST_VIDEO);
					document.body.appendChild(testVideo);
				}
				return testVideo.play();
			};
		})();
		const ima = {};
		class AdDisplayContainer {
			constructor(containerElement) {
				const divElement = document.createElement("div");
				divElement.style.setProperty("display", "none", "important");
				divElement.style.setProperty("visibility", "collapse", "important");
				containerElement.appendChild(divElement);
			}
			destroy() {}
			initialize() {}
		}
		class ImaSdkSettings {
			constructor() {
				this.c = true;
				this.f = {};
				this.i = false;
				this.l = "";
				this.p = "";
				this.r = 0;
				this.t = "";
				this.v = "";
			}
			getCompanionBackfill() {}
			getDisableCustomPlaybackForIOS10Plus() {
				return this.i;
			}
			getFeatureFlags() {
				return this.f;
			}
			getLocale() {
				return this.l;
			}
			getNumRedirects() {
				return this.r;
			}
			getPlayerType() {
				return this.t;
			}
			getPlayerVersion() {
				return this.v;
			}
			getPpid() {
				return this.p;
			}
			isCookiesEnabled() {
				return this.c;
			}
			setAutoPlayAdBreaks() {}
			setCompanionBackfill() {}
			setCookiesEnabled(c) {
				this.c = !!c;
			}
			setDisableCustomPlaybackForIOS10Plus(i) {
				this.i = !!i;
			}
			setFeatureFlags(f) {
				this.f = f;
			}
			setLocale(l) {
				this.l = l;
			}
			setNumRedirects(r) {
				this.r = r;
			}
			setPlayerType(t) {
				this.t = t;
			}
			setPlayerVersion(v) {
				this.v = v;
			}
			setPpid(p) {
				this.p = p;
			}
			setSessionId(/*s*/) {}
			setVpaidAllowed(/*a*/) {}
			setVpaidMode(/*m*/) {}
			// https://github.com/uBlockOrigin/uBlock-issues/issues/2265#issuecomment-1637094149
			getDisableFlashAds() {
			}
			setDisableFlashAds() {
			}
		}
		ImaSdkSettings.CompanionBackfillMode = {
			ALWAYS: "always",
			ON_MASTER_AD: "on_master_ad",
		};
		ImaSdkSettings.VpaidMode = {
			DISABLED: 0,
			ENABLED: 1,
			INSECURE: 2,
		};
		class EventHandler {
			constructor() {
				this.listeners = new Map();
			}
			_dispatch(e) {
				let listeners = this.listeners.get(e.type);
				listeners = listeners ? Array.from(listeners.values()) : [];
				for (const listener of listeners) {
					try {
						listener(e);
					} catch (r) {
						console.error(r);
					}
				}
			}
			addEventListener(types, c, options, context) {
				if (!Array.isArray(types)) {
					types = [types];
				}
				for (const t of types) {
					if (!this.listeners.has(t)) {
						this.listeners.set(t, new Map());
					}
					this.listeners.get(t).set(c, c.bind(context || this));
				}
			}
			removeEventListener(types, c) {
				if (!Array.isArray(types)) {
					types = [types];
				}
				for (const t of types) {
					const typeSet = this.listeners.get(t);
					if (typeSet) {
						typeSet.delete(c);
					}
				}
			}
		}
		class AdsLoader extends EventHandler {
			constructor() {
				super();
				this.settings = new ImaSdkSettings();
			}
			contentComplete() {}
			destroy() {}
			getSettings() {
				return this.settings;
			}
			getVersion() {
				return VERSION;
			}
			requestAds(/*r, c*/) {
				// If autoplay is disabled and the page is trying to autoplay a tracking
				// ad, then IMA fails with an error, and the page is expected to request
				// ads again later when the user clicks to play.
				CheckCanAutoplay().then(
					() => {
						const { ADS_MANAGER_LOADED } = AdsManagerLoadedEvent.Type;
						this._dispatch(new ima.AdsManagerLoadedEvent(ADS_MANAGER_LOADED));
					},
					() => {
						const e = new ima.AdError(
							"adPlayError",
							1205,
							1205,
							"The browser prevented playback initiated without user interaction."
						);
						this._dispatch(new ima.AdErrorEvent(e));
					}
				);
			}
		}
		class AdsManager extends EventHandler {
			constructor() {
				super();
				this.volume = 1;
				this._enablePreloading = false;
			}
			collapse() {}
			configureAdsManager() {}
			destroy() {}
			discardAdBreak() {}
			expand() {}
			focus() {}
			getAdSkippableState() {
				return false;
			}
			getCuePoints() {
				return [0];
			}
			getCurrentAd() {
				return currentAd;
			}
			getCurrentAdCuePoints() {
				return [];
			}
			getRemainingTime() {
				return 0;
			}
			getVolume() {
				return this.volume;
			}
			init(/*w, h, m, e*/) {
				if (this._enablePreloading) {
					this._dispatch(new ima.AdEvent(AdEvent.Type.LOADED));
				}
			}
			isCustomClickTrackingUsed() {
				return false;
			}
			isCustomPlaybackUsed() {
				return false;
			}
			pause() {}
			requestNextAdBreak() {}
			resize(/*w, h, m*/) {}
			resume() {}
			setVolume(v) {
				this.volume = v;
			}
			skip() {}
			start() {
				requestAnimationFrame(() => {
					for (const type of [
						AdEvent.Type.LOADED,
						AdEvent.Type.STARTED,
						AdEvent.Type.CONTENT_PAUSE_REQUESTED,
						AdEvent.Type.AD_BUFFERING,
						AdEvent.Type.FIRST_QUARTILE,
						AdEvent.Type.MIDPOINT,
						AdEvent.Type.THIRD_QUARTILE,
						AdEvent.Type.COMPLETE,
						AdEvent.Type.ALL_ADS_COMPLETED,
						AdEvent.Type.CONTENT_RESUME_REQUESTED,
					]) {
						try {
							this._dispatch(new ima.AdEvent(type));
						} catch (e) {
							console.error(e);
						}
					}
				});
			}
			stop() {}
			updateAdsRenderingSettings(/*s*/) {}
		}
		class AdsRenderingSettings {}
		class AdsRequest {
			setAdWillAutoPlay() {}
			setAdWillPlayMuted() {}
			setContinuousPlayback() {}
		}
		class AdPodInfo {
			getAdPosition() {
				return 1;
			}
			getIsBumper() {
				return false;
			}
			getMaxDuration() {
				return -1;
			}
			getPodIndex() {
				return 1;
			}
			getTimeOffset() {
				return 0;
			}
			getTotalAds() {
				return 1;
			}
		}
		class Ad {
			constructor() {
				this._pi = new AdPodInfo();
			}
			getAdId() {
				return "";
			}
			getAdPodInfo() {
				return this._pi;
			}
			getAdSystem() {
				return "";
			}
			getAdvertiserName() {
				return "";
			}
			getApiFramework() {
				return null;
			}
			getCompanionAds() {
				return [];
			}
			getContentType() {
				return "";
			}
			getCreativeAdId() {
				return "";
			}
			getCreativeId() {
				return "";
			}
			getDealId() {
				return "";
			}
			getDescription() {
				return "";
			}
			getDuration() {
				return 8.5;
			}
			getHeight() {
				return 0;
			}
			getMediaUrl() {
				return null;
			}
			getMinSuggestedDuration() {
				return -2;
			}
			getSkipTimeOffset() {
				return -1;
			}
			getSurveyUrl() {
				return null;
			}
			getTitle() {
				return "";
			}
			getTraffickingParameters() {
				return {};
			}
			getTraffickingParametersString() {
				return "";
			}
			getUiElements() {
				return [""];
			}
			getUniversalAdIdRegistry() {
				return "unknown";
			}
			getUniversalAdIds() {
				return [new UniversalAdIdInfo()];
			}
			getUniversalAdIdValue() {
				return "unknown";
			}
			getVastMediaBitrate() {
				return 0;
			}
			getVastMediaHeight() {
				return 0;
			}
			getVastMediaWidth() {
				return 0;
			}
			getWidth() {
				return 0;
			}
			getWrapperAdIds() {
				return [""];
			}
			getWrapperAdSystems() {
				return [""];
			}
			getWrapperCreativeIds() {
				return [""];
			}
			isLinear() {
				return true;
			}
			isSkippable() {
				return true;
			}
		}
		class CompanionAd {
			getAdSlotId() {
				return "";
			}
			getContent() {
				return "";
			}
			getContentType() {
				return "";
			}
			getHeight() {
				return 1;
			}
			getWidth() {
				return 1;
			}
		}
		class AdError {
			constructor(type, code, vast, message) {
				this.errorCode = code;
				this.message = message;
				this.type = type;
				this.vastErrorCode = vast;
			}
			getErrorCode() {
				return this.errorCode;
			}
			getInnerError() {
					return null;
			}
			getMessage() {
				return this.message;
			}
			getType() {
				return this.type;
			}
			getVastErrorCode() {
				return this.vastErrorCode;
			}
			toString() {
				return `AdError ${this.errorCode}: ${this.message}`;
			}
		}
		AdError.ErrorCode = {};
		AdError.Type = {};
		const isEngadget = () => {
			try {
				for (const ctx of Object.values(window.vidible._getContexts())) {
					const player = ctx.getPlayer();
					if (!player) { continue;}
					const div = player.div;
					if (!div) { continue; }
					if (div.innerHTML.includes("www.engadget.com")) {
						return true;
					}
				}
			} catch (_) {}
			return false;
		};
		const currentAd = isEngadget() ? undefined : new Ad();
		class AdEvent {
			constructor(type) {
				this.type = type;
			}
			getAd() {
				return currentAd;
			}
			getAdData() {
				return {};
			}
		}
		AdEvent.Type = {
			AD_BREAK_READY: "adBreakReady",
			AD_BUFFERING: "adBuffering",
			AD_CAN_PLAY: "adCanPlay",
			AD_METADATA: "adMetadata",
			AD_PROGRESS: "adProgress",
			ALL_ADS_COMPLETED: "allAdsCompleted",
			CLICK: "click",
			COMPLETE: "complete",
			CONTENT_PAUSE_REQUESTED: "contentPauseRequested",
			CONTENT_RESUME_REQUESTED: "contentResumeRequested",
			DURATION_CHANGE: "durationChange",
			EXPANDED_CHANGED: "expandedChanged",
			FIRST_QUARTILE: "firstQuartile",
			IMPRESSION: "impression",
			INTERACTION: "interaction",
			LINEAR_CHANGE: "linearChange",
			LINEAR_CHANGED: "linearChanged",
			LOADED: "loaded",
			LOG: "log",
			MIDPOINT: "midpoint",
			PAUSED: "pause",
			RESUMED: "resume",
			SKIPPABLE_STATE_CHANGED: "skippableStateChanged",
			SKIPPED: "skip",
			STARTED: "start",
			THIRD_QUARTILE: "thirdQuartile",
			USER_CLOSE: "userClose",
			VIDEO_CLICKED: "videoClicked",
			VIDEO_ICON_CLICKED: "videoIconClicked",
			VIEWABLE_IMPRESSION: "viewable_impression",
			VOLUME_CHANGED: "volumeChange",
			VOLUME_MUTED: "mute",
		};
		class AdErrorEvent {
			constructor(error) {
				this.type = "adError";
				this.error = error;
			}
			getError() {
				return this.error;
			}
			getUserRequestContext() {
				return {};
			}
		}
		AdErrorEvent.Type = {
			AD_ERROR: "adError",
		};
		const manager = new AdsManager();
		class AdsManagerLoadedEvent {
			constructor(type) {
				this.type = type;
			}
			getAdsManager(c, settings) {
				if (settings && settings.enablePreloading) {
					manager._enablePreloading = true;
				}
				return manager;
			}
			getUserRequestContext() {
				return {};
			}
		}
		AdsManagerLoadedEvent.Type = {
			ADS_MANAGER_LOADED: "adsManagerLoaded",
		};
		class CustomContentLoadedEvent {}
		CustomContentLoadedEvent.Type = {
			CUSTOM_CONTENT_LOADED: "deprecated-event",
		};
		class CompanionAdSelectionSettings {}
		CompanionAdSelectionSettings.CreativeType = {
			ALL: "All",
			FLASH: "Flash",
			IMAGE: "Image",
		};
		CompanionAdSelectionSettings.ResourceType = {
			ALL: "All",
			HTML: "Html",
			IFRAME: "IFrame",
			STATIC: "Static",
		};
		CompanionAdSelectionSettings.SizeCriteria = {
			IGNORE: "IgnoreSize",
			SELECT_EXACT_MATCH: "SelectExactMatch",
			SELECT_NEAR_MATCH: "SelectNearMatch",
		};
		class AdCuePoints {
			getCuePoints() {
				return [];
			}
		}
		class AdProgressData {}
		class UniversalAdIdInfo {
			getAdIdRegistry() {
				return "";
			}
			getAdIdValue() {
				return "";
			}
		}
		Object.assign(ima, {
			AdCuePoints,
			AdDisplayContainer,
			AdError,
			AdErrorEvent,
			AdEvent,
			AdPodInfo,
			AdProgressData,
			AdsLoader,
			AdsManager: manager,
			AdsManagerLoadedEvent,
			AdsRenderingSettings,
			AdsRequest,
			CompanionAd,
			CompanionAdSelectionSettings,
			CustomContentLoadedEvent,
			gptProxyInstance: {},
			ImaSdkSettings,
			OmidAccessMode: {
				DOMAIN: "domain",
				FULL: "full",
				LIMITED: "limited",
			},
			OmidVerificationVendor: {
				1: "OTHER",
				2: "GOOGLE",
				GOOGLE: 2,
				OTHER: 1
			},
			settings: new ImaSdkSettings(),
			UiElements: {
				AD_ATTRIBUTION: "adAttribution",
				COUNTDOWN: "countdown",
			},
			UniversalAdIdInfo,
			VERSION,
			ViewMode: {
				FULLSCREEN: "fullscreen",
				NORMAL: "normal",
			},
		});
		if (!window.google) {
			window.google = {};
		}
		window.google.ima = ima;
}
})();


# Ubiquitous googletagservices.com: not blocked by EasyPrivacy.
# "Tags are tiny bits of website code that let you measure traffic and
# "visitor behavior"
googletagservices_gpt.js application/javascript
alias googletagservices.com/gpt.js
alias googletagservices-gpt.js
(function() {
	'use strict';
	// https://developers.google.com/doubleclick-gpt/reference
	const noopfn = function() {
	}.bind();
	const noopthisfn = function() {
		return this;
	};
	const noopnullfn = function() {
		return null;
	};
	const nooparrayfn = function() {
		return [];
	};
	const noopstrfn = function() {
		return '';
	};
	//
	const companionAdsService = {
		addEventListener: noopthisfn,
		enableSyncLoading: noopfn,
		setRefreshUnfilledSlots: noopfn
	};
	const contentService = {
		addEventListener: noopthisfn,
		setContent: noopfn
	};
	const PassbackSlot = function() {
	};
	let p = PassbackSlot.prototype;
	p.display = noopfn;
	p.get = noopnullfn;
	p.set = noopthisfn;
	p.setClickUrl = noopthisfn;
	p.setTagForChildDirectedTreatment = noopthisfn;
	p.setTargeting = noopthisfn;
	p.updateTargetingFromMap = noopthisfn;
	const pubAdsService = {
		addEventListener: noopthisfn,
		clear: noopfn,
		clearCategoryExclusions: noopthisfn,
		clearTagForChildDirectedTreatment: noopthisfn,
		clearTargeting: noopthisfn,
		collapseEmptyDivs: noopfn,
		defineOutOfPagePassback: function() { return new PassbackSlot(); },
		definePassback: function() { return new PassbackSlot(); },
		disableInitialLoad: noopfn,
		display: noopfn,
		enableAsyncRendering: noopfn,
		enableLazyLoad: noopfn,
		enableSingleRequest: noopfn,
		enableSyncRendering: noopfn,
		enableVideoAds: noopfn,
		get: noopnullfn,
		getAttributeKeys: nooparrayfn,
		getTargeting: nooparrayfn,
		getTargetingKeys: nooparrayfn,
		getSlots: nooparrayfn,
		refresh: noopfn,
		removeEventListener: noopfn,
		set: noopthisfn,
		setCategoryExclusion: noopthisfn,
		setCentering: noopfn,
		setCookieOptions: noopthisfn,
		setForceSafeFrame: noopthisfn,
		setLocation: noopthisfn,
		setPublisherProvidedId: noopthisfn,
		setPrivacySettings: noopthisfn,
		setRequestNonPersonalizedAds: noopthisfn,
		setSafeFrameConfig: noopthisfn,
		setTagForChildDirectedTreatment: noopthisfn,
		setTargeting: noopthisfn,
		setVideoContent: noopthisfn,
		updateCorrelator: noopfn
	};
	const SizeMappingBuilder = function() {
	};
	p = SizeMappingBuilder.prototype;
	p.addSize = noopthisfn;
	p.build = noopnullfn;
	const Slot = function() {
	};
	p = Slot.prototype;
	p.addService = noopthisfn;
	p.clearCategoryExclusions = noopthisfn;
	p.clearTargeting = noopthisfn;
	p.defineSizeMapping = noopthisfn;
	p.get = noopnullfn;
	p.getAdUnitPath = nooparrayfn;
	p.getAttributeKeys = nooparrayfn;
	p.getCategoryExclusions = nooparrayfn;
	p.getDomId = noopstrfn;
	p.getResponseInformation = noopnullfn;
	p.getSlotElementId = noopstrfn;
	p.getSlotId = noopthisfn;
	p.getTargeting = nooparrayfn;
	p.getTargetingKeys = nooparrayfn;
	p.set = noopthisfn;
	p.setCategoryExclusion = noopthisfn;
	p.setClickUrl = noopthisfn;
	p.setCollapseEmptyDiv = noopthisfn;
	p.setTargeting = noopthisfn;
	p.updateTargetingFromMap = noopthisfn;
	//
	const gpt = window.googletag || {};
	const cmd = gpt.cmd || [];
	gpt.apiReady = true;
	gpt.cmd = [];
	gpt.cmd.push = function(a) {
		try {
			a();
		} catch (ex) {
		}
		return 1;
	};
	gpt.companionAds = function() { return companionAdsService; };
	gpt.content = function() { return contentService; };
	gpt.defineOutOfPageSlot = function() { return new Slot(); };
	gpt.defineSlot = function() { return new Slot(); };
	gpt.destroySlots = noopfn;
	gpt.disablePublisherConsole = noopfn;
	gpt.display = noopfn;
	gpt.enableServices = noopfn;
	gpt.getVersion = noopstrfn;
	gpt.pubads = function() { return pubAdsService; };
	gpt.pubadsReady = true;
	gpt.setAdIframeTitle = noopfn;
	gpt.sizeMapping = function() { return new SizeMappingBuilder(); };
	window.googletag = gpt;
	while ( cmd.length !== 0 ) {
		gpt.cmd.push(cmd.shift());
	}
})();


# https://github.com/uBlockOrigin/uAssets/issues/282
# https://github.com/uBlockOrigin/uAssets/issues/418
googlesyndication_adsbygoogle.js application/javascript
alias googlesyndication.com/adsbygoogle.js
alias googlesyndication-adsbygoogle.js
(function() {
	'use strict';
	const init = ( ) => {
		window.adsbygoogle = {
			loaded: true,
			push: function() {
			}
		};
		const phs = document.querySelectorAll('.adsbygoogle');
		const css = 'height:1px!important;max-height:1px!important;max-width:1px!important;width:1px!important;';
		for ( let i = 0; i < phs.length; i++ ) {
			const id = `aswift_${i}`;
			if ( document.querySelector(`iframe#${id}`) !== null ) { continue; }
			const fr = document.createElement('iframe');
			fr.id = id;
			fr.style = css;
			const cfr = document.createElement('iframe');
			cfr.id = `google_ads_frame${i}`;
			fr.appendChild(cfr);
			phs[i].appendChild(fr);
		}
	};
	if (
		document.querySelectorAll('.adsbygoogle').length === 0 &&
		document.readyState === 'loading'
	) {
		window.addEventListener('DOMContentLoaded', init, { once: true });
	} else {
		init();
	}
})();


# https://forums.lanik.us/viewtopic.php?f=91&t=27188
# https://forums.lanik.us/viewtopic.php?f=91&t=29609
ligatus_angular-tag.js application/javascript
alias ligatus.com/*/angular-tag.js
(function() {
	'use strict';
	self.adProtect = true;
	Object.defineProperties(window, {
		uabpdl: { value: true },
		uabDetect: { value: true }
	});
})();


nobab.js application/javascript
alias bab-defuser.js
alias prevent-bab.js
(function() {
	'use strict';
	const signatures = [
		[ 'blockadblock' ],
		[ 'babasbm' ],
		[ /getItem\('babn'\)/ ],
		[
			'getElementById',
			'String.fromCharCode',
			'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
			'charAt',
			'DOMContentLoaded',
			'AdBlock',
			'addEventListener',
			'doScroll',
			'fromCharCode',
			'<<2|r>>4',
			'sessionStorage',
			'clientWidth',
			'localStorage',
			'Math',
			'random'
		],
	];
	const check = function(s) {
		for ( let i = 0; i < signatures.length; i++ ) {
			const tokens = signatures[i];
			let match = 0;
			for ( let j = 0; j < tokens.length; j++ ) {
				const token = tokens[j];
				const pos = token instanceof RegExp
					? s.search(token)
					: s.indexOf(token);
				if ( pos !== -1 ) { match += 1; }
			}
			if ( (match / tokens.length) >= 0.8 ) { return true; }
		}
		return false;
	};
	self.eval = new Proxy(self.eval, {			  // jshint ignore: line
		apply: function(target, thisArg, args) {
			const a = args[0];
			if ( typeof a !== 'string' || !check(a) ) {
				return target.apply(thisArg, args);
			}
			if ( document.body ) {
				document.body.style.removeProperty('visibility');
			}
			let el = document.getElementById('babasbmsgx');
			if ( el ) {
				el.parentNode.removeChild(el);
			}
		}
	});
	self.setTimeout = new Proxy(self.setTimeout, {
		apply: function(target, thisArg, args) {
			const a = args[0];
			if (
				typeof a !== 'string' ||
				/\.bab_elementid.$/.test(a) === false
			) {
				return target.apply(thisArg, args);
			}
		}
	});
})();


nobab2.js application/javascript
(function() {
	'use strict';
	const script = document.currentScript;
	if ( script === null ) { return; }
	const src = script.src;
	if ( typeof src !== 'string' ) { return; }
	// The scriplet is meant to act ONLY when it's being used as a redirection
	// for specific domains.
	const re = new RegExp(
		'^https?://[\\w-]+\\.(' +
		[
			'adclixx\\.net',
			'adnetasia\\.com',
			'adtrackers\\.net',
			'bannertrack\\.net',
		].join('|') +
		')/.'
	);
	if ( re.test(src) === false ) { return; }
	window.nH7eXzOsG = 858;
})();


scorecardresearch_beacon.js application/javascript
alias scorecardresearch.com/beacon.js
(function() {
	'use strict';
	window.COMSCORE = {
		purge: function() {
			_comscore = [];
		},
		beacon: function() {
			;
		}
	};
})();


# https://github.com/gorhill/uBlock/issues/1250#issuecomment-173533894
outbrain-widget.js application/javascript
alias widgets.outbrain.com/outbrain.js
(function() {
	'use strict';
	const noopfn = function() {
	};
	const obr = {};
	const methods = [
		'callClick',
		'callLoadMore',
		'callRecs',
		'callUserZapping',
		'callWhatIs',
		'cancelRecommendation',
		'cancelRecs',
		'closeCard',
		'closeModal',
		'closeTbx',
		'errorInjectionHandler',
		'getCountOfRecs',
		'getStat',
		'imageError',
		'manualVideoClicked',
		'onOdbReturn',
		'onVideoClick',
		'pagerLoad',
		'recClicked',
		'refreshSpecificWidget',
		'renderSpaWidgets',
		'refreshWidget',
		'reloadWidget',
		'researchWidget',
		'returnedError',
		'returnedHtmlData',
		'returnedIrdData',
		'returnedJsonData',
		'scrollLoad',
		'showDescription',
		'showRecInIframe',
		'userZappingMessage',
		'zappingFormAction'
	];
	obr.extern = {
		video: {
			getVideoRecs: noopfn,
			videoClicked: noopfn
		}
	};
	methods.forEach(function(a) {
		obr.extern[a] = noopfn;
	});
	window.OBR = window.OBR || obr;
})();


# https://github.com/gorhill/uBlock/issues/1228
window.name-defuser.js application/javascript
if ( window === window.top ) {
	window.name = '';
}


# https://github.com/gorhill/uBlock/issues/897#issuecomment-180871042
doubleclick_instream_ad_status.js application/javascript
alias doubleclick.net/instream/ad_status.js
window.google_ad_status = 1;


# Completely experimental: load Disqus on demand only. Purpose is to avoid
# connecting to Disqus' servers, unless the user explicitly asks for the
# comments to be loaded.
# Works with following filters:
# ||disqus.com/forums/*/embed.js$script,redirect=disqus.com/forums/*/embed.js
# ||disqus.com/embed.js$script,redirect=disqus.com/embed.js
# ||disqus.com/count.js$script
# @@||disqus.com/embed.js?_=1457540*$script
# If you want a site you regularly visit to always have the comment loaded,
# just use an exception static filter. Example for wired.com:
# @@||wired.disqus.com/embed.js

# Sometimes a site will use this one script:
disqus_forums_embed.js application/javascript
alias disqus.com/forums/*/embed.js
(function() {
	'use strict';
	let ee = document.getElementsByTagName('script');
	let i = ee.length, src;
	while ( i-- ) {
		src = ee[i].src || '';
		if ( src === '' ) {
			continue;
		}
		if ( src.lastIndexOf('disqus.com/embed.js') === (src.length - 19) ) {
			return;
		}
	}
	let e = document.createElement('script');
	e.async = true;
	e.src = '//' + window.disqus_shortname + '.disqus.com/embed.js';
	document.body.appendChild(e);
})();

# Most use this one though:
disqus_embed.js application/javascript
alias disqus.com/embed.js
(function() {
	'use strict';
	let p = document.getElementById(window.disqus_container_id || 'disqus_thread');
	if ( p === null ) {
		return;
	}
	let b = document.createElement('button');
	b.textContent = 'Disqus blocked by uBlock Origin: click to unblock';
	b.type = 'button';
	p.appendChild(b);
	let loadDisqus = function(ev) {
		b.removeEventListener('click', loadDisqus);
		p.removeChild(b);
		let script = document.createElement('script');
		script.async = true;
		let t = Date.now().toString();
		script.src = '//' + window.disqus_shortname + '.disqus.com/embed.js?_=1457540' + t.slice(-6);
		document.body.appendChild(script);
		ev.preventDefault();
		ev.stopPropagation();
	};
	b.addEventListener('click', loadDisqus);
})();


amazon_ads.js application/javascript
alias amazon-adsystem.com/aax2/amzn_ads.js
(function() {
	'use strict';
	if ( amznads ) {
		return;
	}
	const w = window;
	const noopfn = function() {
		;
	}.bind();
	let amznads = {
		appendScriptTag: noopfn,
		appendTargetingToAdServerUrl: noopfn,
		appendTargetingToQueryString: noopfn,
		clearTargetingFromGPTAsync: noopfn,
		doAllTasks: noopfn,
		doGetAdsAsync: noopfn,
		doTask: noopfn,
		detectIframeAndGetURL: noopfn,
		getAds: noopfn,
		getAdsAsync: noopfn,
		getAdForSlot: noopfn,
		getAdsCallback: noopfn,
		getDisplayAds: noopfn,
		getDisplayAdsAsync: noopfn,
		getDisplayAdsCallback: noopfn,
		getKeys: noopfn,
		getReferrerURL: noopfn,
		getScriptSource: noopfn,
		getTargeting: noopfn,
		getTokens: noopfn,
		getValidMilliseconds: noopfn,
		getVideoAds: noopfn,
		getVideoAdsAsync: noopfn,
		getVideoAdsCallback: noopfn,
		handleCallBack: noopfn,
		hasAds: noopfn,
		renderAd: noopfn,
		saveAds: noopfn,
		setTargeting: noopfn,
		setTargetingForGPTAsync: noopfn,
		setTargetingForGPTSync: noopfn,
		tryGetAdsAsync: noopfn,
		updateAds: noopfn
	};
	w.amznads = amznads;
	w.amzn_ads = w.amzn_ads || noopfn;
	w.aax_write = w.aax_write || noopfn;
	w.aax_render_ad = w.aax_render_ad || noopfn;
})();


# Experimental: Generic nuisance overlay buster.
# if this works well and proves to be useful, this may end up as a stock tool
# in uBO's popup panel.
overlay-buster.js application/javascript
(function() {
	'use strict';
	if ( window !== window.top ) {
		return;
	}
	let tstart;
	const ttl = 30000;
	let delay = 0;
	const delayStep = 50;
	const buster = function(mutations) {
		const docEl = document.documentElement,
			bodyEl = document.body,
			vw = Math.min(docEl.clientWidth, window.innerWidth),
			vh = Math.min(docEl.clientHeight, window.innerHeight),
			tol = Math.min(vw, vh) * 0.05;
			let el = document.elementFromPoint(vw/2, vh/2);
		for (;;) {
			if ( el === null || el.parentNode === null || el === bodyEl ) {
				break;
			}
			const style = window.getComputedStyle(el);
			if ( parseInt(style.zIndex, 10) >= 1000 || style.position === 'fixed' ) {
				const rect = el.getBoundingClientRect();
				if ( rect.left <= tol && rect.top <= tol && (vw - rect.right) <= tol && (vh - rect.bottom) < tol ) {
					el.parentNode.removeChild(el);
					tstart = Date.now();
					el = document.elementFromPoint(vw/2, vh/2);
					bodyEl.style.setProperty('overflow', 'auto', 'important');
					docEl.style.setProperty('overflow', 'auto', 'important');
					continue;
				}
			}
			el = el.parentNode;
		}
		if ( (Date.now() - tstart) < ttl ) {
			delay = Math.min(delay + delayStep, 1000);
			setTimeout(buster, delay);
		}
	};
	const domReady = function(ev) {
		if ( ev ) {
			document.removeEventListener(ev.type, domReady);
		}
		tstart = Date.now();
		setTimeout(buster, delay);
	};
	if ( document.readyState === 'loading' ) {
		document.addEventListener('DOMContentLoaded', domReady);
	} else {
		domReady();
	}
})();


# https://github.com/uBlockOrigin/uAssets/issues/8
alert-buster.js application/javascript
(function() {
	'use strict';
	window.alert = new Proxy(window.alert, {
		apply: function(target, thisArg, args) {
			console.info(`uBO: Suppressed alert... ${args[0]}`);
		},
		get(target, prop, receiver) {
			if ( prop === 'toString' ) {
				return target.toString.bind(target);
			}
			return Reflect.get(target, prop, receiver);
		},
	});
})();


# https://www.reddit.com/r/uBlockOrigin/comments/q0frv0/while_reading_a_sports_article_i_was_redirected/hf7wo9v/
prevent-refresh.js application/javascript
alias refresh-defuser.js
function(arg1) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'addEventListener': self.EventTarget.prototype.addEventListener,
			'removeEventListener': self.EventTarget.prototype.removeEventListener,
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function runAt(fn, when) {
		const intFromReadyState = state => {
			const targets = {
				'loading': 1,
				'interactive': 2, 'end': 2, '2': 2,
				'complete': 3, 'idle': 3, '3': 3,
			};
			const tokens = Array.isArray(state) ? state : [ state ];
			for ( const token of tokens ) {
				const prop = `${token}`;
				if ( targets.hasOwnProperty(prop) === false ) { continue; }
				return targets[prop];
			}
			return 0;
		};
		const runAt = intFromReadyState(when);
		if ( intFromReadyState(document.readyState) >= runAt ) {
			fn(); return;
		}
		const onStateChange = ( ) => {
			if ( intFromReadyState(document.readyState) < runAt ) { return; }
			fn();
			safe.removeEventListener.apply(document, args);
		};
		const safe = safeSelf();
		const args = [ 'readystatechange', onStateChange, { capture: true } ];
		safe.addEventListener.apply(document, args);
	}
	if ( arg1 === undefined ) { arg1 = ''; }
	const log = console.log.bind(console, makeLogPrefix('prevent-refresh', arg1));
	const defuse = ( ) => {
		const meta = document.querySelector('meta[http-equiv="refresh" i][content]');
		if ( meta === null ) { return; }
		log(`Prevented "${meta.textContent}"`);
		const s = arg1 === ''
			? meta.getAttribute('content')
			: arg1;
		const ms = Math.max(parseFloat(s) || 0, 0) * 1000;
		setTimeout(( ) => { window.stop(); }, ms);
	};
	runAt(( ) => {
		defuse();
	}, 'interactive');
}


# Prevent web pages from using eval(), and report attempts in console.
noeval.js application/javascript
(function() {
	'use strict';
	self.eval = new Proxy(self.eval, {			// jshint ignore: line
		apply: function(target, thisArg, args) {
			console.log(`uBO: Document tried to eval... ${args[0]}`);
		}
	});
})();

noeval-silent.js application/javascript
alias silent-noeval.js
(function() {
	'use strict';
	self.eval = new Proxy(self.eval, {			// jshint ignore: line
		apply: function() {
		}
	});
})();

noeval-if.js application/javascript
alias prevent-eval-if.js
function(needle) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	if ( needle === undefined ) { needle = ''; }
	const safe = safeSelf();
	const reNeedle = safe.patternToRegex(needle);
	self.eval = new Proxy(self.eval, {  // jshint ignore: line
		apply: function(target, thisArg, args) {
			if ( reNeedle.test(args[0].toString()) ) { return; }
			return Reflect.apply(target, thisArg, args);
		}
	});
}


# Prevent a function call from throwing. The function will be called, however
# should it throw, the scriptlet will silently process the exception and
# return as if no exception has occurred.
# Parameter is a chain of dot-separated properties which leads to the
# function to be trapped.
call-nothrow.js application/javascript
function(chain) {
	'use strict';
	if ( chain === undefined || chain === '' ) { return; }
	const parts = chain.split('.');
	let owner = window, prop;
	for (;;) {
		prop = parts.shift();
		if ( parts.length === 0 ) { break; }
		owner = owner[prop];
		if ( owner instanceof Object === false ) { return; }
	}
	if ( prop === '' ) { return; }
	const fn = owner[prop];
	if ( typeof fn !== 'function' ) { return; }
	owner[prop] = new Proxy(fn, {
		apply: function(...args) {
			let r;
			try {
				r = Reflect.apply(...args);
			} catch(ex) {
			}
			return r;
		},
	});
}


# Prevent web pages from using RTCPeerConnection(), and report attempts in console.
nowebrtc.js application/javascript
(function() {
	'use strict';
	const rtcName = window.RTCPeerConnection ? 'RTCPeerConnection' : (
		window.webkitRTCPeerConnection ? 'webkitRTCPeerConnection' : ''
	);
	if ( rtcName === '' ) { return; }
	const log = console.log.bind(console, 'uBO:');
	const pc = function(cfg) {
		log('Document tried to create an RTCPeerConnection: %o', cfg);
	};
	const noop = function() {
		;
	};
	pc.prototype = {
		close: noop,
		createDataChannel: noop,
		createOffer: noop,
		setRemoteDescription: noop,
		toString: function() {
			return '[object RTCPeerConnection]';
		}
	};
	const z = window[rtcName];
	window[rtcName] = pc.bind(window);
	if ( z.prototype ) {
		z.prototype.createDataChannel = function() {
			return {
				close: function() {},
				send: function() {}
			};
		}.bind(null);
	}
})();


webrtc-if.js application/javascript
function(good) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	if ( good === undefined || good === '' ) { return; }
	const safe = safeSelf();
	const reGood = safe.patternToRegex(good);
	const rtcName = window.RTCPeerConnection
		? 'RTCPeerConnection'
		: (window.webkitRTCPeerConnection ? 'webkitRTCPeerConnection' : '');
	if ( rtcName === '' ) { return; }
	const log = console.log.bind(console, 'uBO:');
	const neuteredPeerConnections = new WeakSet();
	const isGoodConfig = function(instance, config) {
		if ( neuteredPeerConnections.has(instance) ) { return false; }
		if ( config instanceof Object === false ) { return true; }
		if ( Array.isArray(config.iceServers) === false ) { return true; }
		for ( const server of config.iceServers ) {
			const urls = typeof server.urls === 'string'
				? [ server.urls ]
				: server.urls;
			if ( Array.isArray(urls) ) {
				for ( const url of urls ) {
					if ( reGood.test(url) ) { return true; }
				}
			}
			if ( typeof server.username === 'string' ) {
				if ( reGood.test(server.username) ) { return true; }
			}
			if ( typeof server.credential === 'string' ) {
				if ( reGood.test(server.credential) ) { return true; }
			}
		}
		neuteredPeerConnections.add(instance);
		return false;
	};
	const peerConnectionCtor = window[rtcName];
	const peerConnectionProto = peerConnectionCtor.prototype;
	peerConnectionProto.createDataChannel =
		new Proxy(peerConnectionProto.createDataChannel, {
			apply: function(target, thisArg, args) {
				if ( isGoodConfig(target, args[1]) === false ) {
					log(args[1]);
					return Reflect.apply(target, thisArg, args.slice(0, 1));
				}
				return Reflect.apply(target, thisArg, args);
			},
		});
	window[rtcName] =
		new Proxy(peerConnectionCtor, {
			construct: function(target, args) {
				if ( isGoodConfig(target, args[0]) === false ) {
					log(args[0]);
					return Reflect.construct(target);
				}
				return Reflect.construct(target, args);
			}
		});
}


# Parameter is a specific type of canvas API to prevent (default to all
# APIs). Can be a string or regex which will be matched against the type
# used in getContext() call. Prepend with `!` to test for no-match.
#
# Reference: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
prevent-canvas.js application/javascript
function(contextType) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'RegExp': self.RegExp,
			'RegExp_test': self.RegExp.prototype.test,
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			initPattern(pattern, options = {}) {
				if ( pattern === '' ) {
					return { matchAll: true };
				}
				const expect = (options.canNegate !== true || pattern.startsWith('!') === false);
				if ( expect === false ) {
					pattern = pattern.slice(1);
				}
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match !== null ) {
					return {
						re: new this.RegExp(
							match[1],
							match[2] || options.flags
						),
						expect,
					};
				}
				if ( options.flags !== undefined ) {
					return {
						re: new this.RegExp(this.escapeRegexChars(pattern),
							options.flags
						),
						expect,
					};
				}
				return { pattern, expect };
			},
			testPattern(details, haystack) {
				if ( details.matchAll ) { return true; }
				if ( details.re ) {
					return this.RegExp_test.call(details.re, haystack) === details.expect;
				}
				return haystack.includes(details.pattern) === details.expect;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	if ( contextType === undefined ) { contextType = ''; }
	const safe = safeSelf();
	const pattern = safe.initPattern(contextType, { canNegate: true });
	const proto = self.HTMLCanvasElement.prototype;
	proto.getContext = new Proxy(proto.getContext, {
		apply(target, thisArg, args) {
			if ( safe.testPattern(pattern, args[0]) ) { return null; }
			return Reflect.apply(target, thisArg, args);
		}
	});
}


# https://www.reddit.com/r/firefox/comments/4wpd23/popads_just_announced_that_they_have_a_new_method/
popads.js application/javascript
alias popads.net.js
alias prevent-popads-net.js
(function() {
	'use strict';
	const magic = String.fromCharCode(Date.now() % 26 + 97) +
				  Math.floor(Math.random() * 982451653 + 982451653).toString(36);
	const oe = window.onerror;
	window.onerror = function(msg, src, line, col, error) {
		if ( typeof msg === 'string' && msg.indexOf(magic) !== -1 ) { return true; }
		if ( oe instanceof Function ) {
			return oe(msg, src, line, col, error);
		}
	}.bind();
	const throwMagic = function() { throw new ReferenceError(magic); };
	delete window.PopAds;
	delete window.popns;
	Object.defineProperties(window, {
		PopAds: { set: throwMagic },
		popns: { set: throwMagic }
	});
})();


# https://github.com/uBlockOrigin/uAssets/issues/503
popads-dummy.js application/javascript
(function() {
	'use strict';
	delete window.PopAds;
	delete window.popns;
	Object.defineProperties(window, {
		PopAds: { value: {} },
		popns: { value: {} }
	});
})();


# https://twitter.com/Scarbir/status/785551814460571648
chartbeat.js application/javascript
alias static.chartbeat.com/chartbeat.js
(function() {
	'use strict';
	const noopfn = function() {
	};
	window.pSUPERFLY = {
		activity: noopfn,
		virtualPage: noopfn
	};
	for ( const hider of document.querySelectorAll('style[id^=chartbeat-flicker-control]') ) {
		hider.remove();
	}
})();


# https://github.com/gorhill/uBlock/issues/2132
abort-on-property-write.js application/javascript
alias aopw.js
function(prop) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Math_floor': Math.floor,
			'Math_random': Math.random,
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `[${args.join(' \u205D ')}]` || '';
	}
	function getExceptionToken() {
		const safe = safeSelf();
		const token =
			String.fromCharCode(Date.now() % 26 + 97) +
			safe.Math_floor(safe.Math_random() * 982451653 + 982451653).toString(36);
		const oe = self.onerror;
		self.onerror = function(msg, ...args) {
			if ( typeof msg === 'string' && msg.includes(token) ) { return true; }
			if ( oe instanceof Function ) {
				return oe.call(this, msg, ...args);
			}
		}.bind();
		return token;
	}
	if ( prop === undefined || prop === '' ) { return; }
	const log = console.log.bind(console, makeLogPrefix('abort-on-property-write', prop));
	const exceptionToken = getExceptionToken();
	let owner = window;
	for (;;) {
		const pos = prop.indexOf('.');
		if ( pos === -1 ) { break; }
		owner = owner[prop.slice(0, pos)];
		if ( owner instanceof Object === false ) { return; }
		prop = prop.slice(pos + 1);
	}
	delete owner[prop];
	Object.defineProperty(owner, prop, {
		set: function() {
			log(logPrefix, 'Aborted');
			throw new ReferenceError(exceptionToken);
		}
	});
}


abort-on-property-read.js application/javascript
alias aopr.js
function(chain) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Math_floor': Math.floor,
			'Math_random': Math.random,
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `[${args.join(' \u205D ')}]` || '';
	}
	function getExceptionToken() {
		const safe = safeSelf();
		const token =
			String.fromCharCode(Date.now() % 26 + 97) +
			safe.Math_floor(safe.Math_random() * 982451653 + 982451653).toString(36);
		const oe = self.onerror;
		self.onerror = function(msg, ...args) {
			if ( typeof msg === 'string' && msg.includes(token) ) { return true; }
			if ( oe instanceof Function ) {
				return oe.call(this, msg, ...args);
			}
		}.bind();
		return token;
	}
	if ( chain === undefined || chain === '' ) { return; }
	const log = console.log.bind(console, makeLogPrefix('abort-on-property-read', prop));
	const exceptionToken = getExceptionToken();
	const abort = function() {
		log('Aborted');
		throw new ReferenceError(exceptionToken);
	};
	const makeProxy = function(owner, chain) {
		const pos = chain.indexOf('.');
		if ( pos === -1 ) {
			const desc = Object.getOwnPropertyDescriptor(owner, chain);
			if ( !desc || desc.get !== abort ) {
				Object.defineProperty(owner, chain, {
					get: abort,
					set: function(){}
				});
			}
			return;
		}
		const prop = chain.slice(0, pos);
		let v = owner[prop];
		chain = chain.slice(pos + 1);
		if ( v ) {
			makeProxy(v, chain);
			return;
		}
		const desc = Object.getOwnPropertyDescriptor(owner, prop);
		if ( desc && desc.set !== undefined ) { return; }
		Object.defineProperty(owner, prop, {
			get: function() { return v; },
			set: function(a) {
				v = a;
				if ( a instanceof Object ) {
					makeProxy(a, chain);
				}
			}
		});
	};
	makeProxy(window, chain);
}


abort-on-stack-trace.js application/javascript
alias aost.js
function(chain, needle) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Error': self.Error,
			'Math_floor': Math.floor,
			'Math_random': Math.random,
			'Object_fromEntries': Object.fromEntries.bind(Object),
			'RegExp': self.RegExp,
			'RegExp_test': self.RegExp.prototype.test,
			'RegExp_exec': self.RegExp.prototype.exec,
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			initPattern(pattern, options = {}) {
				if ( pattern === '' ) {
					return { matchAll: true };
				}
				const expect = (options.canNegate !== true || pattern.startsWith('!') === false);
				if ( expect === false ) {
					pattern = pattern.slice(1);
				}
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match !== null ) {
					return {
						re: new this.RegExp(
							match[1],
							match[2] || options.flags
						),
						expect,
					};
				}
				if ( options.flags !== undefined ) {
					return {
						re: new this.RegExp(this.escapeRegexChars(pattern),
							options.flags
						),
						expect,
					};
				}
				return { pattern, expect };
			},
			testPattern(details, haystack) {
				if ( details.matchAll ) { return true; }
				if ( details.re ) {
					return this.RegExp_test.call(details.re, haystack) === details.expect;
				}
				return haystack.includes(details.pattern) === details.expect;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `[${args.join(' \u205D ')}]` || '';
	}
	function getExceptionToken() {
		const safe = safeSelf();
		const token =
			String.fromCharCode(Date.now() % 26 + 97) +
			safe.Math_floor(safe.Math_random() * 982451653 + 982451653).toString(36);
		const oe = self.onerror;
		self.onerror = function(msg, ...args) {
			if ( typeof msg === 'string' && msg.includes(token) ) { return true; }
			if ( oe instanceof Function ) {
				return oe.call(this, msg, ...args);
			}
		}.bind();
		return token;
	}
	function matchesStackTrace(
		needleDetails,
		logLevel = ''
	) {
		const safe = safeSelf();
		const log = console.log.bind(console);
		const exceptionToken = getExceptionToken();
		const error = new safe.Error(exceptionToken);
		const docURL = new URL(self.location.href);
		docURL.hash = '';
		// Normalize stack trace
		const reLine = /(.*?@)?(\S+)(:\d+):\d+\)?$/;
		const lines = [];
		for ( let line of error.stack.split(/[\n\r]+/) ) {
			if ( line.includes(exceptionToken) ) { continue; }
			line = line.trim();
			const match = safe.RegExp_exec.call(reLine, line);
			if ( match === null ) { continue; }
			let url = match[2];
			if ( url.startsWith('(') ) { url = url.slice(1); }
			if ( url === docURL.href ) {
				url = 'inlineScript';
			} else if ( url.startsWith('<anonymous>') ) {
				url = 'injectedScript';
			}
			let fn = match[1] !== undefined
				? match[1].slice(0, -1)
				: line.slice(0, match.index).trim();
			if ( fn.startsWith('at') ) { fn = fn.slice(2).trim(); }
			let rowcol = match[3];
			lines.push(' ' + `${fn} ${url}${rowcol}:1`.trim());
		}
		lines[0] = `stackDepth:${lines.length-1}`;
		const stack = lines.join('\t');
		const r = needleDetails.matchAll !== true &&
			safe.testPattern(needleDetails, stack);
		if (
			logLevel === 'all' ||
			logLevel === 'match' && r ||
			logLevel === 'nomatch' && !r
		) {
			log(stack.replace(/\t/g, '\n'));
		}
		return r;
	}
	if ( chain === undefined || chain === '' ) { return; }
	if ( needle === undefined ) { needle = ''; }
	const safe = safeSelf();
	const needleDetails = safe.initPattern(needle, { canNegate: true });
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 2);
	if ( needle === '' ) { extraArgs.log = 'all'; }
	const makeProxy = function(owner, chain) {
		const pos = chain.indexOf('.');
		if ( pos === -1 ) {
			let v = owner[chain];
			Object.defineProperty(owner, chain, {
				get: function() {
					if ( matchesStackTrace(needleDetails, extraArgs.log) ) {
						throw new ReferenceError(getExceptionToken());
					}
					return v;
				},
				set: function(a) {
					if ( matchesStackTrace(needleDetails, extraArgs.log) ) {
						throw new ReferenceError(getExceptionToken());
					}
					v = a;
				},
			});
			return;
		}
		const prop = chain.slice(0, pos);
		let v = owner[prop];
		chain = chain.slice(pos + 1);
		if ( v ) {
			makeProxy(v, chain);
			return;
		}
		const desc = Object.getOwnPropertyDescriptor(owner, prop);
		if ( desc && desc.set !== undefined ) { return; }
		Object.defineProperty(owner, prop, {
			get: function() { return v; },
			set: function(a) {
				v = a;
				if ( a instanceof Object ) {
					makeProxy(a, chain);
				}
			}
		});
	};
	makeProxy(window, chain);
}


# https://github.com/gorhill/uBlock/commit/9367a6015b8cbb6b49347b00a105aab8f24df861
no-setTimeout-if.js application/javascript
alias nostif.js
alias prevent-setTimeout.js
alias setTimeout-defuser.js
function(needle, delay) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Function_toStringFn': self.Function.prototype.toString,
			'Function_toString': thisArg => safe.Function_toStringFn.call(thisArg),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `[${args.join(' \u205D ')}]` || '';
	}
	if ( needle === undefined ) { needle = ''; }
	if ( delay === undefined ) { delay = ''; }
	const safe = safeSelf();
	const log = console.log.bind(console, makeLogPrefix('prevent-setTimeout', needle, delay));
	const needleNot = needle.charAt(0) === '!';
	if ( needleNot ) { needle = needle.slice(1); }
	let delayNot = false;
	if ( delay !== undefined ) {
		delayNot = delay.charAt(0) === '!';
		if ( delayNot ) { delay = delay.slice(1); }
		delay = parseInt(delay, 10);
	}
	const reNeedle = safe.patternToRegex(needle);
	self.setTimeout = new Proxy(self.setTimeout, {
		apply: function(target, thisArg, args) {
			const a = args[0] instanceof Function
				? String(safe.Function_toString(args[0]))
				: String(args[0]);
			const b = args[1];
			if ( needle === '' && delay === undefined ) {
				log(`Called:\n${a}\n${b}`);
				return Reflect.apply(target, thisArg, args);
			}
			let defuse;
			if ( needle !== '' ) {
				defuse = reNeedle.test(a) !== needleNot;
			}
			if ( defuse !== false && delay !== undefined ) {
				defuse = (b === delay || isNaN(b) && isNaN(delay) ) !== delayNot;
			}
			if ( defuse ) {
				args[0] = function(){};
				log(`Prevented:\n${a}\n${b}`);
			}
			return Reflect.apply(target, thisArg, args);
		},
		get(target, prop, receiver) {
			if ( prop === 'toString' ) {
				return target.toString.bind(target);
			}
			return Reflect.get(target, prop, receiver);
		},
	});
}


# https://github.com/gorhill/uBlock/commit/9367a6015b8cbb6b49347b00a105aab8f24df861
no-setInterval-if.js application/javascript
alias nosiif.js
alias prevent-setInterval.js
alias setInterval-defuser.js
function(needle, delay) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Function_toStringFn': self.Function.prototype.toString,
			'Function_toString': thisArg => safe.Function_toStringFn.call(thisArg),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `[${args.join(' \u205D ')}]` || '';
	}
	if ( needle === undefined ) { needle = ''; }
	const safe = safeSelf();
	const log = console.log.bind(console, makeLogPrefix('prevent-setInterval', needle, delay));
	const needleNot = needle.charAt(0) === '!';
	if ( needleNot ) { needle = needle.slice(1); }
	let delayNot = false;
	if ( delay !== undefined ) {
		delayNot = delay.charAt(0) === '!';
		if ( delayNot ) { delay = delay.slice(1); }
		delay = parseInt(delay, 10);
	}
	const reNeedle = safe.patternToRegex(needle);
	self.setInterval = new Proxy(self.setInterval, {
		apply: function(target, thisArg, args) {
			const a = args[0] instanceof Function
				? String(safe.Function_toString(args[0]))
				: String(args[0]);
			const b = args[1];
			if ( needle === '' && delay === undefined ) {
				log(`Called:\n${a}\n${b}`);
				return Reflect.apply(target, thisArg, args);
			}
			let defuse;
			if ( needle !== '' ) {
				defuse = reNeedle.test(a) !== needleNot;
			}
			if ( defuse !== false && delay !== undefined ) {
				defuse = (b === delay || isNaN(b) && isNaN(delay) ) !== delayNot;
			}
			if ( defuse ) {
				args[0] = function(){};
				log(`Prevented:\n${a}\n${b}`);
			}
			return Reflect.apply(target, thisArg, args);
		},
		get(target, prop, receiver) {
			if ( prop === 'toString' ) {
				return target.toString.bind(target);
			}
			return Reflect.get(target, prop, receiver);
		},
	});
}


# https://github.com/gorhill/uBlock/commit/2fd86a66fcc2665e5672cc5862e24b3782ee7504
#
#  When no "prune paths" argument is provided, the scriptlet is
#  used for logging purpose and the "needle paths" argument is
#  used to filter logging output.
#
#  https://github.com/uBlockOrigin/uBlock-issues/issues/1545
#  - Add support for "remove everything if needle matches" case
json-prune.js application/javascript
function(rawPrunePaths, rawNeedlePaths, stackNeedle) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Error': self.Error,
			'Math_floor': Math.floor,
			'Math_random': Math.random,
			'Object_fromEntries': Object.fromEntries.bind(Object),
			'RegExp': self.RegExp,
			'RegExp_test': self.RegExp.prototype.test,
			'RegExp_exec': self.RegExp.prototype.exec,
			'JSON': self.JSON,
			'JSON_stringifyFn': self.JSON.stringify,
			'JSON_stringify': (...args) => safe.JSON_stringifyFn.call(safe.JSON, ...args),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			initPattern(pattern, options = {}) {
				if ( pattern === '' ) {
					return { matchAll: true };
				}
				const expect = (options.canNegate !== true || pattern.startsWith('!') === false);
				if ( expect === false ) {
					pattern = pattern.slice(1);
				}
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match !== null ) {
					return {
						re: new this.RegExp(
							match[1],
							match[2] || options.flags
						),
						expect,
					};
				}
				if ( options.flags !== undefined ) {
					return {
						re: new this.RegExp(this.escapeRegexChars(pattern),
							options.flags
						),
						expect,
					};
				}
				return { pattern, expect };
			},
			testPattern(details, haystack) {
				if ( details.matchAll ) { return true; }
				if ( details.re ) {
					return this.RegExp_test.call(details.re, haystack) === details.expect;
				}
				return haystack.includes(details.pattern) === details.expect;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function getExceptionToken() {
		const safe = safeSelf();
		const token =
			String.fromCharCode(Date.now() % 26 + 97) +
			safe.Math_floor(safe.Math_random() * 982451653 + 982451653).toString(36);
		const oe = self.onerror;
		self.onerror = function(msg, ...args) {
			if ( typeof msg === 'string' && msg.includes(token) ) { return true; }
			if ( oe instanceof Function ) {
				return oe.call(this, msg, ...args);
			}
		}.bind();
		return token;
	}
	function matchesStackTrace(
		needleDetails,
		logLevel = ''
	) {
		const safe = safeSelf();
		const log = console.log.bind(console);
		const exceptionToken = getExceptionToken();
		const error = new safe.Error(exceptionToken);
		const docURL = new URL(self.location.href);
		docURL.hash = '';
		// Normalize stack trace
		const reLine = /(.*?@)?(\S+)(:\d+):\d+\)?$/;
		const lines = [];
		for ( let line of error.stack.split(/[\n\r]+/) ) {
			if ( line.includes(exceptionToken) ) { continue; }
			line = line.trim();
			const match = safe.RegExp_exec.call(reLine, line);
			if ( match === null ) { continue; }
			let url = match[2];
			if ( url.startsWith('(') ) { url = url.slice(1); }
			if ( url === docURL.href ) {
				url = 'inlineScript';
			} else if ( url.startsWith('<anonymous>') ) {
				url = 'injectedScript';
			}
			let fn = match[1] !== undefined
				? match[1].slice(0, -1)
				: line.slice(0, match.index).trim();
			if ( fn.startsWith('at') ) { fn = fn.slice(2).trim(); }
			let rowcol = match[3];
			lines.push(' ' + `${fn} ${url}${rowcol}:1`.trim());
		}
		lines[0] = `stackDepth:${lines.length-1}`;
		const stack = lines.join('\t');
		const r = needleDetails.matchAll !== true &&
			safe.testPattern(needleDetails, stack);
		if (
			logLevel === 'all' ||
			logLevel === 'match' && r ||
			logLevel === 'nomatch' && !r
		) {
			log(stack.replace(/\t/g, '\n'));
		}
		return r;
	}
	function objectFindOwnerFn(
		root,
		path,
		prune = false
	) {
		let owner = root;
		let chain = path;
		for (;;) {
			if ( typeof owner !== 'object' || owner === null  ) { return false; }
			const pos = chain.indexOf('.');
			if ( pos === -1 ) {
				if ( prune === false ) {
					return owner.hasOwnProperty(chain);
				}
				let modified = false;
				if ( chain === '*' ) {
					for ( const key in owner ) {
						if ( owner.hasOwnProperty(key) === false ) { continue; }
						delete owner[key];
						modified = true;
					}
				} else if ( owner.hasOwnProperty(chain) ) {
					delete owner[chain];
					modified = true;
				}
				return modified;
			}
			const prop = chain.slice(0, pos);
			const next = chain.slice(pos + 1);
			let found = false;
			if ( prop === '[-]' && Array.isArray(owner) ) {
				let i = owner.length;
				while ( i-- ) {
					if ( objectFindOwnerFn(owner[i], next) === false ) { continue; }
					owner.splice(i, 1);
					found = true;
				}
				return found;
			}
			if ( prop === '{-}' && owner instanceof Object ) {
				for ( const key of Object.keys(owner) ) {
					if ( objectFindOwnerFn(owner[key], next) === false ) { continue; }
					delete owner[key];
					found = true;
				}
				return found;
			}
			if (
				prop === '[]' && Array.isArray(owner) ||
				prop === '{}' && owner instanceof Object ||
				prop === '*' && owner instanceof Object
			) {
				for ( const key of Object.keys(owner) ) {
					if (objectFindOwnerFn(owner[key], next, prune) === false ) { continue; }
					found = true;
				}
				return found;
			}
			if ( owner.hasOwnProperty(prop) === false ) { return false; }
			owner = owner[prop];
			chain = chain.slice(pos + 1);
		}
	}
	function objectPruneFn(
		obj,
		rawPrunePaths,
		rawNeedlePaths,
		stackNeedleDetails = { matchAll: true },
		extraArgs = {}
	) {
		if ( typeof rawPrunePaths !== 'string' ) { return; }
		const prunePaths = rawPrunePaths !== ''
			? rawPrunePaths.split(/ +/)
			: [];
		const needlePaths = prunePaths.length !== 0 && rawNeedlePaths !== ''
			? rawNeedlePaths.split(/ +/)
			: [];
		if ( stackNeedleDetails.matchAll !== true ) {
			if ( matchesStackTrace(stackNeedleDetails, extraArgs.logstack) === false ) {
				return;
			}
		}
		if ( objectPruneFn.mustProcess === undefined ) {
			objectPruneFn.mustProcess = (root, needlePaths) => {
				for ( const needlePath of needlePaths ) {
					if ( objectFindOwnerFn(root, needlePath) === false ) {
						return false;
					}
				}
				return true;
			};
		}
		if ( prunePaths.length === 0 ) { return; }
		let outcome = 'nomatch';
		if ( objectPruneFn.mustProcess(obj, needlePaths) ) {
			for ( const path of prunePaths ) {
				if ( objectFindOwnerFn(obj, path, true) ) {
					outcome = 'match';
				}
			}
		}
		if ( outcome === 'match' ) { return obj; }
	}
	if ( rawPrunePaths === undefined ) { rawPrunePaths = ''; }
	if ( rawNeedlePaths === undefined ) { rawNeedlePaths = ''; }
	if ( stackNeedle === undefined ) { stackNeedle = ''; }
	const safe = safeSelf();
	const log = console.log.bind(console, makeLogPrefix('json-prune', rawPrunePaths, rawNeedlePaths, stackNeedle));
	const stackNeedleDetails = safe.initPattern(stackNeedle, { canNegate: true });
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 3);
	JSON.parse = new Proxy(JSON.parse, {
		apply: function(target, thisArg, args) {
			const objBefore = Reflect.apply(target, thisArg, args);
			if ( rawPrunePaths === '' ) {
				log(safe.JSON_stringify(objBefore, null, 2));
			}
			const objAfter = objectPruneFn(
				objBefore,
				rawPrunePaths,
				rawNeedlePaths,
				stackNeedleDetails,
				extraArgs
			);
			if ( objAfter === undefined ) { return objBefore; }
			if ( extraArgs.scriptletLogLevel > 1 ) {
				log(`After pruning:\n${safe.JSON_stringify(objAfter, null, 2)}`);
			}
			return objAfter;
		},
	});
}


json-prune-fetch-response.js application/javascript
function(rawPrunePaths, rawNeedlePaths) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Array_from': Array.from,
			'Error': self.Error,
			'Object_fromEntries': Object.fromEntries.bind(Object),
			'RegExp': self.RegExp,
			'RegExp_test': self.RegExp.prototype.test,
			'RegExp_exec': self.RegExp.prototype.exec,
			'Request_clone': self.Request.prototype.clone,
			'JSON': self.JSON,
			'JSON_stringifyFn': self.JSON.stringify,
			'JSON_stringify': (...args) => safe.JSON_stringifyFn.call(safe.JSON, ...args),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			initPattern(pattern, options = {}) {
				if ( pattern === '' ) {
					return { matchAll: true };
				}
				const expect = (options.canNegate !== true || pattern.startsWith('!') === false);
				if ( expect === false ) {
					pattern = pattern.slice(1);
				}
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match !== null ) {
					return {
						re: new this.RegExp(
							match[1],
							match[2] || options.flags
						),
						expect,
					};
				}
				if ( options.flags !== undefined ) {
					return {
						re: new this.RegExp(this.escapeRegexChars(pattern),
							options.flags
						),
						expect,
					};
				}
				return { pattern, expect };
			},
			testPattern(details, haystack) {
				if ( details.matchAll ) { return true; }
				if ( details.re ) {
					return this.RegExp_test.call(details.re, haystack) === details.expect;
				}
				return haystack.includes(details.pattern) === details.expect;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function parsePropertiesToMatch(propsToMatch, implicit = '') {
		const safe = safeSelf();
		const needles = new Map();
		if ( propsToMatch === undefined || propsToMatch === '' ) { return needles; }
		const options = { canNegate: true };
		for ( const needle of propsToMatch.split(/\s+/) ) {
			const [ prop, pattern ] = needle.split(':');
			if ( prop === '' ) { continue; }
			if ( pattern !== undefined ) {
				needles.set(prop, safe.initPattern(pattern, options));
			} else if ( implicit !== '' ) {
				needles.set(implicit, safe.initPattern(prop, options));
			}
		}
		return needles;
	}
	function matchesStackTrace(
		needleDetails,
		logLevel = ''
	) {
		const safe = safeSelf();
		const log = console.log.bind(console);
		const exceptionToken = getExceptionToken();
		const error = new safe.Error(exceptionToken);
		const docURL = new URL(self.location.href);
		docURL.hash = '';
		// Normalize stack trace
		const reLine = /(.*?@)?(\S+)(:\d+):\d+\)?$/;
		const lines = [];
		for ( let line of error.stack.split(/[\n\r]+/) ) {
			if ( line.includes(exceptionToken) ) { continue; }
			line = line.trim();
			const match = safe.RegExp_exec.call(reLine, line);
			if ( match === null ) { continue; }
			let url = match[2];
			if ( url.startsWith('(') ) { url = url.slice(1); }
			if ( url === docURL.href ) {
				url = 'inlineScript';
			} else if ( url.startsWith('<anonymous>') ) {
				url = 'injectedScript';
			}
			let fn = match[1] !== undefined
				? match[1].slice(0, -1)
				: line.slice(0, match.index).trim();
			if ( fn.startsWith('at') ) { fn = fn.slice(2).trim(); }
			let rowcol = match[3];
			lines.push(' ' + `${fn} ${url}${rowcol}:1`.trim());
		}
		lines[0] = `stackDepth:${lines.length-1}`;
		const stack = lines.join('\t');
		const r = needleDetails.matchAll !== true &&
			safe.testPattern(needleDetails, stack);
		if (
			logLevel === 'all' ||
			logLevel === 'match' && r ||
			logLevel === 'nomatch' && !r
		) {
			log(stack.replace(/\t/g, '\n'));
		}
		return r;
	}
	function objectFindOwnerFn(
		root,
		path,
		prune = false
	) {
		let owner = root;
		let chain = path;
		for (;;) {
			if ( typeof owner !== 'object' || owner === null  ) { return false; }
			const pos = chain.indexOf('.');
			if ( pos === -1 ) {
				if ( prune === false ) {
					return owner.hasOwnProperty(chain);
				}
				let modified = false;
				if ( chain === '*' ) {
					for ( const key in owner ) {
						if ( owner.hasOwnProperty(key) === false ) { continue; }
						delete owner[key];
						modified = true;
					}
				} else if ( owner.hasOwnProperty(chain) ) {
					delete owner[chain];
					modified = true;
				}
				return modified;
			}
			const prop = chain.slice(0, pos);
			const next = chain.slice(pos + 1);
			let found = false;
			if ( prop === '[-]' && Array.isArray(owner) ) {
				let i = owner.length;
				while ( i-- ) {
					if ( objectFindOwnerFn(owner[i], next) === false ) { continue; }
					owner.splice(i, 1);
					found = true;
				}
				return found;
			}
			if ( prop === '{-}' && owner instanceof Object ) {
				for ( const key of Object.keys(owner) ) {
					if ( objectFindOwnerFn(owner[key], next) === false ) { continue; }
					delete owner[key];
					found = true;
				}
				return found;
			}
			if (
				prop === '[]' && Array.isArray(owner) ||
				prop === '{}' && owner instanceof Object ||
				prop === '*' && owner instanceof Object
			) {
				for ( const key of Object.keys(owner) ) {
					if (objectFindOwnerFn(owner[key], next, prune) === false ) { continue; }
					found = true;
				}
				return found;
			}
			if ( owner.hasOwnProperty(prop) === false ) { return false; }
			owner = owner[prop];
			chain = chain.slice(pos + 1);
		}
	}
	function objectPruneFn(
		obj,
		rawPrunePaths,
		rawNeedlePaths,
		stackNeedleDetails = { matchAll: true },
		extraArgs = {}
	) {
		if ( typeof rawPrunePaths !== 'string' ) { return; }
		const prunePaths = rawPrunePaths !== ''
			? rawPrunePaths.split(/ +/)
			: [];
		const needlePaths = prunePaths.length !== 0 && rawNeedlePaths !== ''
			? rawNeedlePaths.split(/ +/)
			: [];
		if ( stackNeedleDetails.matchAll !== true ) {
			if ( matchesStackTrace(stackNeedleDetails, extraArgs.logstack) === false ) {
				return;
			}
		}
		if ( objectPruneFn.mustProcess === undefined ) {
			objectPruneFn.mustProcess = (root, needlePaths) => {
				for ( const needlePath of needlePaths ) {
					if ( objectFindOwnerFn(root, needlePath) === false ) {
						return false;
					}
				}
				return true;
			};
		}
		if ( prunePaths.length === 0 ) { return; }
		let outcome = 'nomatch';
		if ( objectPruneFn.mustProcess(obj, needlePaths) ) {
			for ( const path of prunePaths ) {
				if ( objectFindOwnerFn(obj, path, true) ) {
					outcome = 'match';
				}
			}
		}
		if ( outcome === 'match' ) { return obj; }
	}
	function matchObjectProperties(propNeedles, ...objs) {
		if ( matchObjectProperties.extractProperties === undefined ) {
			matchObjectProperties.extractProperties = (src, des, props) => {
				for ( const p of props ) {
					const v = src[p];
					if ( v === undefined ) { continue; }
					des[p] = src[p];
				}
			};
		}
		const safe = safeSelf();
		const haystack = {};
		const props = safe.Array_from(propNeedles.keys());
		for ( const obj of objs ) {
			if ( obj instanceof Object === false ) { continue; }
			matchObjectProperties.extractProperties(obj, haystack, props);
		}
		for ( const [ prop, details ] of propNeedles ) {
			let value = haystack[prop];
			if ( value === undefined ) { continue; }
			if ( typeof value !== 'string' ) {
				try { value = safe.JSON_stringify(value); }
				catch(ex) { }
				if ( typeof value !== 'string' ) { continue; }
			}
			if ( safe.testPattern(details, value) ) { continue; }
			return false;
		}
		return true;
	}
	if ( rawPrunePaths === undefined ) { rawPrunePaths = ''; }
	if ( rawNeedlePaths === undefined ) { rawNeedlePaths = ''; }
	const safe = safeSelf();
	const logPrefix = makeLogPrefix('json-prune-fetch-response', rawPrunePaths, rawNeedlePaths);
	const log = console.log.bind(console, logPrefix);
	const logErr = console.error.bind(console, logPrefix);
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 2);
	const propNeedles = parsePropertiesToMatch(extraArgs.propsToMatch, 'url');
	const stackNeedle = safe.initPattern(extraArgs.stackToMatch || '', { canNegate: true });
	const logall = rawPrunePaths === '';
	const applyHandler = function(target, thisArg, args) {
		const fetchPromise = Reflect.apply(target, thisArg, args);
		let outcome = logall ? 'nomatch' : 'match';
		if ( propNeedles.size !== 0 ) {
			const objs = [ args[0] instanceof Object ? args[0] : { url: args[0] } ];
			if ( objs[0] instanceof Request ) {
				if ( !objs[0].bodyUsed ) {
					objs[0] = safe.Request_clone.call(objs[0]);
				}
			}
			if ( args[1] instanceof Object ) {
				objs.push(args[1]);
			}
			if ( matchObjectProperties(propNeedles, ...objs) === false ) {
				outcome = 'nomatch';
			}
		}
		if ( logall === false && outcome === 'nomatch' ) { return fetchPromise; }
		if ( extraArgs.scripletLogLevel > 1 && outcome !== 'nomatch' && propNeedles.size !== 0 ) {
			log(`Matched optional "propsToMatch"\n${extraArgs.propsToMatch}`);
		}
		return fetchPromise.then(responseBefore => {
			const response = responseBefore.clone();
			return response.json().then(objBefore => {
				if ( typeof objBefore !== 'object' ) { return responseBefore; }
				if ( logall ) {
					log(JSON.stringify(objBefore, null, 2));
					return responseBefore;
				}
				const objAfter = objectPruneFn(
					objBefore,
					rawPrunePaths,
					rawNeedlePaths,
					stackNeedle,
					extraArgs
				);
				if ( typeof objAfter !== 'object' ) { return responseBefore; }
				log('Pruned');
				const responseAfter = Response.json(objAfter, {
					status: responseBefore.status,
					statusText: responseBefore.statusText,
					headers: responseBefore.headers,
				});
				Object.defineProperties(responseAfter, {
					ok: { value: responseBefore.ok },
					redirected: { value: responseBefore.redirected },
					type: { value: responseBefore.type },
					url: { value: responseBefore.url },
				});
				return responseAfter;
			}).catch(reason => {
				logErr(reason);
				return responseBefore;
			});
		}).catch(reason => {
			logErr(reason);
			return fetchPromise;
		});
	};
	self.fetch = new Proxy(self.fetch, {
		apply: applyHandler
	});
}


json-prune-xhr-response.js application/javascript
function(rawPrunePaths, rawNeedlePaths) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Array_from': Array.from,
			'Error': self.Error,
			'Object_fromEntries': Object.fromEntries.bind(Object),
			'RegExp': self.RegExp,
			'RegExp_test': self.RegExp.prototype.test,
			'RegExp_exec': self.RegExp.prototype.exec,
			'JSON': self.JSON,
			'JSON_parseFn': self.JSON.parse,
			'JSON_stringifyFn': self.JSON.stringify,
			'JSON_parse': (...args) => safe.JSON_parseFn.call(safe.JSON, ...args),
			'JSON_stringify': (...args) => safe.JSON_stringifyFn.call(safe.JSON, ...args),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			initPattern(pattern, options = {}) {
				if ( pattern === '' ) {
					return { matchAll: true };
				}
				const expect = (options.canNegate !== true || pattern.startsWith('!') === false);
				if ( expect === false ) {
					pattern = pattern.slice(1);
				}
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match !== null ) {
					return {
						re: new this.RegExp(
							match[1],
							match[2] || options.flags
						),
						expect,
					};
				}
				if ( options.flags !== undefined ) {
					return {
						re: new this.RegExp(this.escapeRegexChars(pattern),
							options.flags
						),
						expect,
					};
				}
				return { pattern, expect };
			},
			testPattern(details, haystack) {
				if ( details.matchAll ) { return true; }
				if ( details.re ) {
					return this.RegExp_test.call(details.re, haystack) === details.expect;
				}
				return haystack.includes(details.pattern) === details.expect;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function parsePropertiesToMatch(propsToMatch, implicit = '') {
		const safe = safeSelf();
		const needles = new Map();
		if ( propsToMatch === undefined || propsToMatch === '' ) { return needles; }
		const options = { canNegate: true };
		for ( const needle of propsToMatch.split(/\s+/) ) {
			const [ prop, pattern ] = needle.split(':');
			if ( prop === '' ) { continue; }
			if ( pattern !== undefined ) {
				needles.set(prop, safe.initPattern(pattern, options));
			} else if ( implicit !== '' ) {
				needles.set(implicit, safe.initPattern(prop, options));
			}
		}
		return needles;
	}
	function matchesStackTrace(
		needleDetails,
		logLevel = ''
	) {
		const safe = safeSelf();
		const log = console.log.bind(console);
		const exceptionToken = getExceptionToken();
		const error = new safe.Error(exceptionToken);
		const docURL = new URL(self.location.href);
		docURL.hash = '';
		// Normalize stack trace
		const reLine = /(.*?@)?(\S+)(:\d+):\d+\)?$/;
		const lines = [];
		for ( let line of error.stack.split(/[\n\r]+/) ) {
			if ( line.includes(exceptionToken) ) { continue; }
			line = line.trim();
			const match = safe.RegExp_exec.call(reLine, line);
			if ( match === null ) { continue; }
			let url = match[2];
			if ( url.startsWith('(') ) { url = url.slice(1); }
			if ( url === docURL.href ) {
				url = 'inlineScript';
			} else if ( url.startsWith('<anonymous>') ) {
				url = 'injectedScript';
			}
			let fn = match[1] !== undefined
				? match[1].slice(0, -1)
				: line.slice(0, match.index).trim();
			if ( fn.startsWith('at') ) { fn = fn.slice(2).trim(); }
			let rowcol = match[3];
			lines.push(' ' + `${fn} ${url}${rowcol}:1`.trim());
		}
		lines[0] = `stackDepth:${lines.length-1}`;
		const stack = lines.join('\t');
		const r = needleDetails.matchAll !== true &&
			safe.testPattern(needleDetails, stack);
		if (
			logLevel === 'all' ||
			logLevel === 'match' && r ||
			logLevel === 'nomatch' && !r
		) {
			log(stack.replace(/\t/g, '\n'));
		}
		return r;
	}
	function objectFindOwnerFn(
		root,
		path,
		prune = false
	) {
		let owner = root;
		let chain = path;
		for (;;) {
			if ( typeof owner !== 'object' || owner === null  ) { return false; }
			const pos = chain.indexOf('.');
			if ( pos === -1 ) {
				if ( prune === false ) {
					return owner.hasOwnProperty(chain);
				}
				let modified = false;
				if ( chain === '*' ) {
					for ( const key in owner ) {
						if ( owner.hasOwnProperty(key) === false ) { continue; }
						delete owner[key];
						modified = true;
					}
				} else if ( owner.hasOwnProperty(chain) ) {
					delete owner[chain];
					modified = true;
				}
				return modified;
			}
			const prop = chain.slice(0, pos);
			const next = chain.slice(pos + 1);
			let found = false;
			if ( prop === '[-]' && Array.isArray(owner) ) {
				let i = owner.length;
				while ( i-- ) {
					if ( objectFindOwnerFn(owner[i], next) === false ) { continue; }
					owner.splice(i, 1);
					found = true;
				}
				return found;
			}
			if ( prop === '{-}' && owner instanceof Object ) {
				for ( const key of Object.keys(owner) ) {
					if ( objectFindOwnerFn(owner[key], next) === false ) { continue; }
					delete owner[key];
					found = true;
				}
				return found;
			}
			if (
				prop === '[]' && Array.isArray(owner) ||
				prop === '{}' && owner instanceof Object ||
				prop === '*' && owner instanceof Object
			) {
				for ( const key of Object.keys(owner) ) {
					if (objectFindOwnerFn(owner[key], next, prune) === false ) { continue; }
					found = true;
				}
				return found;
			}
			if ( owner.hasOwnProperty(prop) === false ) { return false; }
			owner = owner[prop];
			chain = chain.slice(pos + 1);
		}
	}
	function objectPruneFn(
		obj,
		rawPrunePaths,
		rawNeedlePaths,
		stackNeedleDetails = { matchAll: true },
		extraArgs = {}
	) {
		if ( typeof rawPrunePaths !== 'string' ) { return; }
		const prunePaths = rawPrunePaths !== ''
			? rawPrunePaths.split(/ +/)
			: [];
		const needlePaths = prunePaths.length !== 0 && rawNeedlePaths !== ''
			? rawNeedlePaths.split(/ +/)
			: [];
		if ( stackNeedleDetails.matchAll !== true ) {
			if ( matchesStackTrace(stackNeedleDetails, extraArgs.logstack) === false ) {
				return;
			}
		}
		if ( objectPruneFn.mustProcess === undefined ) {
			objectPruneFn.mustProcess = (root, needlePaths) => {
				for ( const needlePath of needlePaths ) {
					if ( objectFindOwnerFn(root, needlePath) === false ) {
						return false;
					}
				}
				return true;
			};
		}
		if ( prunePaths.length === 0 ) { return; }
		let outcome = 'nomatch';
		if ( objectPruneFn.mustProcess(obj, needlePaths) ) {
			for ( const path of prunePaths ) {
				if ( objectFindOwnerFn(obj, path, true) ) {
					outcome = 'match';
				}
			}
		}
		if ( outcome === 'match' ) { return obj; }
	}
	function matchObjectProperties(propNeedles, ...objs) {
		if ( matchObjectProperties.extractProperties === undefined ) {
			matchObjectProperties.extractProperties = (src, des, props) => {
				for ( const p of props ) {
					const v = src[p];
					if ( v === undefined ) { continue; }
					des[p] = src[p];
				}
			};
		}
		const safe = safeSelf();
		const haystack = {};
		const props = safe.Array_from(propNeedles.keys());
		for ( const obj of objs ) {
			if ( obj instanceof Object === false ) { continue; }
			matchObjectProperties.extractProperties(obj, haystack, props);
		}
		for ( const [ prop, details ] of propNeedles ) {
			let value = haystack[prop];
			if ( value === undefined ) { continue; }
			if ( typeof value !== 'string' ) {
				try { value = safe.JSON_stringify(value); }
				catch(ex) { }
				if ( typeof value !== 'string' ) { continue; }
			}
			if ( safe.testPattern(details, value) ) { continue; }
			return false;
		}
		return true;
	}
	if ( rawPrunePaths === undefined ) { rawPrunePaths = ''; }
	if ( rawNeedlePaths === undefined ) { rawNeedlePaths = ''; }
	const safe = safeSelf();
	const log = console.log.bind(console, makeLogPrefix('json-prune-xhr-response', rawPrunePaths, rawNeedlePaths));
	const xhrInstances = new WeakMap();
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 2);
	const propNeedles = parsePropertiesToMatch(extraArgs.propsToMatch, 'url');
	const stackNeedle = safe.initPattern(extraArgs.stackToMatch || '', { canNegate: true });
	self.XMLHttpRequest = class extends self.XMLHttpRequest {
		open(method, url, ...args) {
			const xhrDetails = { method, url };
			let outcome = 'match';
			if ( propNeedles.size !== 0 ) {
				if ( matchObjectProperties(propNeedles, xhrDetails) === false ) {
					outcome = 'nomatch';
				}
			}
			if ( outcome === 'match' ) {
				if ( extraArgs.scriptletLogLevel > 1 ) {
					log(`Matched optional "propsToMatch", "${extraArgs.propsToMatch}"`);
				}
				xhrInstances.set(this, xhrDetails);
			}
			return super.open(method, url, ...args);
		}
		get response() {
			const innerResponse = super.response;
			const xhrDetails = xhrInstances.get(this);
			if ( xhrDetails === undefined ) {
				return innerResponse;
			}
			const responseLength = typeof innerResponse === 'string'
				? innerResponse.length
				: undefined;
			if ( xhrDetails.lastResponseLength !== responseLength ) {
				xhrDetails.response = undefined;
				xhrDetails.lastResponseLength = responseLength;
			}
			if ( xhrDetails.response !== undefined ) {
				return xhrDetails.response;
			}
			let objBefore;
			if ( typeof innerResponse === 'object' ) {
				objBefore = innerResponse;
			} else if ( typeof innerResponse === 'string' ) {
				try {
					objBefore = safe.JSON_parse(innerResponse);
				} catch(ex) {
				}
			}
			if ( typeof objBefore !== 'object' ) {
				return (xhrDetails.response = innerResponse);
			}
			const objAfter = objectPruneFn(
				objBefore,
				rawPrunePaths,
				rawNeedlePaths,
				stackNeedle,
				extraArgs
			);
			let outerResponse;
			if ( typeof objAfter === 'object' ) {
				outerResponse = typeof innerResponse === 'string'
					? safe.JSON_stringify(objAfter)
					: objAfter;
				log('Pruned');
			} else {
				outerResponse = innerResponse;
			}
			return (xhrDetails.response = outerResponse);
		}
		get responseText() {
			const response = this.response;
			return typeof response !== 'string'
				? super.responseText
				: response;
		}
	};
}


# There is still code out there which uses `eval` in lieu of `JSON.parse`.
evaldata-prune.js application/javascript
function(rawPrunePaths, rawNeedlePaths) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Error': self.Error,
			'Math_floor': Math.floor,
			'Math_random': Math.random,
			'RegExp_test': self.RegExp.prototype.test,
			'RegExp_exec': self.RegExp.prototype.exec,
			testPattern(details, haystack) {
				if ( details.matchAll ) { return true; }
				if ( details.re ) {
					return this.RegExp_test.call(details.re, haystack) === details.expect;
				}
				return haystack.includes(details.pattern) === details.expect;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function getExceptionToken() {
		const safe = safeSelf();
		const token =
			String.fromCharCode(Date.now() % 26 + 97) +
			safe.Math_floor(safe.Math_random() * 982451653 + 982451653).toString(36);
		const oe = self.onerror;
		self.onerror = function(msg, ...args) {
			if ( typeof msg === 'string' && msg.includes(token) ) { return true; }
			if ( oe instanceof Function ) {
				return oe.call(this, msg, ...args);
			}
		}.bind();
		return token;
	}
	function matchesStackTrace(
		needleDetails,
		logLevel = ''
	) {
		const safe = safeSelf();
		const log = console.log.bind(console);
		const exceptionToken = getExceptionToken();
		const error = new safe.Error(exceptionToken);
		const docURL = new URL(self.location.href);
		docURL.hash = '';
		// Normalize stack trace
		const reLine = /(.*?@)?(\S+)(:\d+):\d+\)?$/;
		const lines = [];
		for ( let line of error.stack.split(/[\n\r]+/) ) {
			if ( line.includes(exceptionToken) ) { continue; }
			line = line.trim();
			const match = safe.RegExp_exec.call(reLine, line);
			if ( match === null ) { continue; }
			let url = match[2];
			if ( url.startsWith('(') ) { url = url.slice(1); }
			if ( url === docURL.href ) {
				url = 'inlineScript';
			} else if ( url.startsWith('<anonymous>') ) {
				url = 'injectedScript';
			}
			let fn = match[1] !== undefined
				? match[1].slice(0, -1)
				: line.slice(0, match.index).trim();
			if ( fn.startsWith('at') ) { fn = fn.slice(2).trim(); }
			let rowcol = match[3];
			lines.push(' ' + `${fn} ${url}${rowcol}:1`.trim());
		}
		lines[0] = `stackDepth:${lines.length-1}`;
		const stack = lines.join('\t');
		const r = needleDetails.matchAll !== true &&
			safe.testPattern(needleDetails, stack);
		if (
			logLevel === 'all' ||
			logLevel === 'match' && r ||
			logLevel === 'nomatch' && !r
		) {
			log(stack.replace(/\t/g, '\n'));
		}
		return r;
	}
	function objectFindOwnerFn(
		root,
		path,
		prune = false
	) {
		let owner = root;
		let chain = path;
		for (;;) {
			if ( typeof owner !== 'object' || owner === null  ) { return false; }
			const pos = chain.indexOf('.');
			if ( pos === -1 ) {
				if ( prune === false ) {
					return owner.hasOwnProperty(chain);
				}
				let modified = false;
				if ( chain === '*' ) {
					for ( const key in owner ) {
						if ( owner.hasOwnProperty(key) === false ) { continue; }
						delete owner[key];
						modified = true;
					}
				} else if ( owner.hasOwnProperty(chain) ) {
					delete owner[chain];
					modified = true;
				}
				return modified;
			}
			const prop = chain.slice(0, pos);
			const next = chain.slice(pos + 1);
			let found = false;
			if ( prop === '[-]' && Array.isArray(owner) ) {
				let i = owner.length;
				while ( i-- ) {
					if ( objectFindOwnerFn(owner[i], next) === false ) { continue; }
					owner.splice(i, 1);
					found = true;
				}
				return found;
			}
			if ( prop === '{-}' && owner instanceof Object ) {
				for ( const key of Object.keys(owner) ) {
					if ( objectFindOwnerFn(owner[key], next) === false ) { continue; }
					delete owner[key];
					found = true;
				}
				return found;
			}
			if (
				prop === '[]' && Array.isArray(owner) ||
				prop === '{}' && owner instanceof Object ||
				prop === '*' && owner instanceof Object
			) {
				for ( const key of Object.keys(owner) ) {
					if (objectFindOwnerFn(owner[key], next, prune) === false ) { continue; }
					found = true;
				}
				return found;
			}
			if ( owner.hasOwnProperty(prop) === false ) { return false; }
			owner = owner[prop];
			chain = chain.slice(pos + 1);
		}
	}
	function objectPruneFn(
		obj,
		rawPrunePaths,
		rawNeedlePaths,
		stackNeedleDetails = { matchAll: true },
		extraArgs = {}
	) {
		if ( typeof rawPrunePaths !== 'string' ) { return; }
		const prunePaths = rawPrunePaths !== ''
			? rawPrunePaths.split(/ +/)
			: [];
		const needlePaths = prunePaths.length !== 0 && rawNeedlePaths !== ''
			? rawNeedlePaths.split(/ +/)
			: [];
		if ( stackNeedleDetails.matchAll !== true ) {
			if ( matchesStackTrace(stackNeedleDetails, extraArgs.logstack) === false ) {
				return;
			}
		}
		if ( objectPruneFn.mustProcess === undefined ) {
			objectPruneFn.mustProcess = (root, needlePaths) => {
				for ( const needlePath of needlePaths ) {
					if ( objectFindOwnerFn(root, needlePath) === false ) {
						return false;
					}
				}
				return true;
			};
		}
		if ( prunePaths.length === 0 ) { return; }
		let outcome = 'nomatch';
		if ( objectPruneFn.mustProcess(obj, needlePaths) ) {
			for ( const path of prunePaths ) {
				if ( objectFindOwnerFn(obj, path, true) ) {
					outcome = 'match';
				}
			}
		}
		if ( outcome === 'match' ) { return obj; }
	}
	if ( rawPrunePaths === undefined ) { rawPrunePaths = ''; }
	if ( rawNeedlePaths === undefined ) { rawNeedlePaths = ''; }
	self.eval = new Proxy(self.eval, {
		apply(target, thisArg, args) {
			const before = Reflect.apply(target, thisArg, args);
			if ( typeof before === 'object' ) {
				const after = objectPruneFn(before, rawPrunePaths, rawNeedlePaths);
				return after || before;
			}
			return before;
		}
	});
}


xml-prune.js application/javascript
function(selector, selectorCheck, urlPattern) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Object_fromEntries': Object.fromEntries.bind(Object),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	if ( selector === undefined || selector === '' ) { return; }
	if ( selectorCheck === undefined ) { selectorCheck = ''; }
	if ( urlPattern === undefined ) { urlPattern = ''; }
	const safe = safeSelf();
	const logPrefix = makeLogPrefix('xml-prune', selector, selectorCheck, urlPattern);
	const log = console.log.bind(console, logPrefix);
	const logErr = console.error.bind(console, logPrefix);
	const reUrl = safe.patternToRegex(urlPattern);
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 3);
	const queryAll = (xmlDoc, selector) => {
		const isXpath = /^xpath\(.+\)$/.test(selector);
		if ( isXpath === false ) {
			return Array.from(xmlDoc.querySelectorAll(selector));
		}
		const xpr = xmlDoc.evaluate(
			selector.slice(6, -1),
			xmlDoc,
			null,
			XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,
			null
		);
		const out = [];
		for ( let i = 0; i < xpr.snapshotLength; i++ ) {
			const node = xpr.snapshotItem(i);
			out.push(node);
		}
		return out;
	};
	const pruneFromDoc = xmlDoc => {
		try {
			if ( selectorCheck !== '' && xmlDoc.querySelector(selectorCheck) === null ) {
				return xmlDoc;
			}
			if ( extraArgs.logdoc ) {
				const serializer = new XMLSerializer();
				log(`Document is\n\t${serializer.serializeToString(xmlDoc)}`);
			}
			const items = queryAll(xmlDoc, selector);
			if ( items.length === 0 ) { return xmlDoc; }
			log(`Removing ${items.length} items`);
			for ( const item of items ) {
				if ( item.nodeType === 1 ) {
					item.remove();
				} else if ( item.nodeType === 2 ) {
					item.ownerElement.removeAttribute(item.nodeName);
				}
				log(`${item.constructor.name}.${item.nodeName} removed`);
			}
		} catch(ex) {
			logErr(`Error: ${ex}`);
		}
		return xmlDoc;
	};
	const pruneFromText = text => {
		if ( (/^\s*</.test(text) && />\s*$/.test(text)) === false ) {
			return text;
		}
		try {
			const xmlParser = new DOMParser();
			const xmlDoc = xmlParser.parseFromString(text, 'text/xml');
			pruneFromDoc(xmlDoc);
			const serializer = new XMLSerializer();
			text = serializer.serializeToString(xmlDoc);
		} catch(ex) {
		}
		return text;
	};
	const urlFromArg = arg => {
		if ( typeof arg === 'string' ) { return arg; }
		if ( arg instanceof Request ) { return arg.url; }
		return String(arg);
	};
	self.fetch = new Proxy(self.fetch, {
		apply: function(target, thisArg, args) {
			const fetchPromise = Reflect.apply(target, thisArg, args);
			if ( reUrl.test(urlFromArg(args[0])) === false ) {
				return fetchPromise;
			}
			return fetchPromise.then(responseBefore => {
				const response = responseBefore.clone();
				return response.text().then(text => {
					const responseAfter = new Response(pruneFromText(text), {
						status: responseBefore.status,
						statusText: responseBefore.statusText,
						headers: responseBefore.headers,
					});
					Object.defineProperties(responseAfter, {
						ok: { value: responseBefore.ok },
						redirected: { value: responseBefore.redirected },
						type: { value: responseBefore.type },
						url: { value: responseBefore.url },
					});
					return responseAfter;
				}).catch(( ) =>
					responseBefore
				);
			});
		}
	});
	self.XMLHttpRequest.prototype.open = new Proxy(self.XMLHttpRequest.prototype.open, {
		apply: async (target, thisArg, args) => {
			if ( reUrl.test(urlFromArg(args[1])) === false ) {
				return Reflect.apply(target, thisArg, args);
			}
			thisArg.addEventListener('readystatechange', function() {
				if ( thisArg.readyState !== 4 ) { return; }
				const type = thisArg.responseType;
				if (
					type === 'document' ||
					type === '' && thisArg.responseXML instanceof XMLDocument
				) {
					pruneFromDoc(thisArg.responseXML);
					const serializer = new XMLSerializer();
					const textout = serializer.serializeToString(thisArg.responseXML);
					Object.defineProperty(thisArg, 'responseText', { value: textout });
					return;
				}
				if (
					type === 'text' ||
					type === '' && typeof thisArg.responseText === 'string'
				) {
					const textin = thisArg.responseText;
					const textout = pruneFromText(textin);
					if ( textout === textin ) { return; }
					Object.defineProperty(thisArg, 'response', { value: textout });
					Object.defineProperty(thisArg, 'responseText', { value: textout });
					return;
				}
			});
			return Reflect.apply(target, thisArg, args);
		}
	});
}


m3u-prune.js application/javascript
function(m3uPattern, urlPattern) {
	'use strict';
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	if ( m3uPattern === undefined ) { m3uPattern = ''; }
	if ( urlPattern === undefined ) { urlPattern = ''; }
	const logPrefix = makeLogPrefix('m3u-prune', m3uPattern, urlPattern);
	const log = console.log.bind(console, logPrefix);
	const logErr = console.error.bind(console, logPrefix);
	const toLog = [];
	const regexFromArg = arg => {
		if ( arg === '' ) { return /^/; }
		const match = /^\/(.+)\/([gms]*)$/.exec(arg);
		if ( match !== null ) {
			let flags = match[2] || '';
			if ( flags.includes('m') ) { flags += 's'; }
			return new RegExp(match[1], flags);
		}
		return new RegExp(
			arg.replace(/[.+?^${}()|[\]\\]/g, '\\$&').replace(/\*+/g, '.*?')
		);
	};
	const reM3u = regexFromArg(m3uPattern);
	const reUrl = regexFromArg(urlPattern);
	const pruneSpliceoutBlock = (lines, i) => {
		if ( lines[i].startsWith('#EXT-X-CUE:TYPE="SpliceOut"') === false ) {
			return false;
		}
		toLog.push(`\t${lines[i]}`);
		lines[i] = undefined; i += 1;
		if ( lines[i].startsWith('#EXT-X-ASSET:CAID') ) {
			toLog.push(`\t${lines[i]}`);
			lines[i] = undefined; i += 1;
		}
		if ( lines[i].startsWith('#EXT-X-SCTE35:') ) {
			toLog.push(`\t${lines[i]}`);
			lines[i] = undefined; i += 1;
		}
		if ( lines[i].startsWith('#EXT-X-CUE-IN') ) {
			toLog.push(`\t${lines[i]}`);
			lines[i] = undefined; i += 1;
		}
		if ( lines[i].startsWith('#EXT-X-SCTE35:') ) {
			toLog.push(`\t${lines[i]}`);
			lines[i] = undefined; i += 1;
		}
		return true;
	};
	const pruneInfBlock = (lines, i) => {
		if ( lines[i].startsWith('#EXTINF') === false ) { return false; }
		if ( reM3u.test(lines[i+1]) === false ) { return false; }
		toLog.push('Discarding', `\t${lines[i]}, \t${lines[i+1]}`);
		lines[i] = lines[i+1] = undefined; i += 2;
		if ( lines[i].startsWith('#EXT-X-DISCONTINUITY') ) {
			toLog.push(`\t${lines[i]}`);
			lines[i] = undefined; i += 1;
		}
		return true;
	};
	const pruner = text => {
		if ( (/^\s*#EXTM3U/.test(text)) === false ) { return text; }
		if ( reM3u.multiline ) {
			reM3u.lastIndex = 0;
			for (;;) {
				const match = reM3u.exec(text);
				if ( match === null ) { break; }
				let discard = match[0];
				let before = text.slice(0, match.index);
				if (
					/^[\n\r]+/.test(discard) === false &&
					/[\n\r]+$/.test(before) === false
				) {
					const startOfLine = /[^\n\r]+$/.exec(before);
					if ( startOfLine !== null ) {
						before = before.slice(0, startOfLine.index);
						discard = startOfLine[0] + discard;
					}
				}
				let after = text.slice(match.index + match[0].length);
				if (
					/[\n\r]+$/.test(discard) === false &&
					/^[\n\r]+/.test(after) === false
				) {
					const endOfLine = /^[^\n\r]+/.exec(after);
					if ( endOfLine !== null ) {
						after = after.slice(endOfLine.index);
						discard += discard + endOfLine[0];
					}
				}
				text = before.trim() + '\n' + after.trim();
				reM3u.lastIndex = before.length + 1;
				toLog.push('Discarding', ...discard.split(/\n+/).map(s => `\t${s}`));
				if ( reM3u.global === false ) { break; }
			}
			return text;
		}
		const lines = text.split(/\n\r|\n|\r/);
		for ( let i = 0; i < lines.length; i++ ) {
			if ( lines[i] === undefined ) { continue; }
			if ( pruneSpliceoutBlock(lines, i) ) { continue; }
			if ( pruneInfBlock(lines, i) ) { continue; }
		}
		return lines.filter(l => l !== undefined).join('\n');
	};
	const urlFromArg = arg => {
		if ( typeof arg === 'string' ) { return arg; }
		if ( arg instanceof Request ) { return arg.url; }
		return String(arg);
	};
	self.fetch = new Proxy(self.fetch, {
		apply: function(target, thisArg, args) {
			const fetchPromise = Reflect.apply(target, thisArg, args);
			if ( reUrl.test(urlFromArg(args[0])) === false ) {
				return fetchPromise;
			}
			return fetchPromise.then(realResponse => {
				realResponse.text().then(text => {
					const response = new Response(pruner(text), {
						status: realResponse.status,
						statusText: realResponse.statusText,
						headers: realResponse.headers,
					});
					if ( toLog.length !== 0 ) {
						toLog.unshift(logPrefix);
						log(toLog.join('\n'));
					}
					return response;
				});
			});
		}
	});
	self.XMLHttpRequest.prototype.open = new Proxy(self.XMLHttpRequest.prototype.open, {
		apply: async (target, thisArg, args) => {
			if ( reUrl.test(urlFromArg(args[1])) === false ) {
				return Reflect.apply(target, thisArg, args);
			}
			thisArg.addEventListener('readystatechange', function() {
				if ( thisArg.readyState !== 4 ) { return; }
				const type = thisArg.responseType;
				if ( type !== '' && type !== 'text' ) { return; }
				const textin = thisArg.responseText;
				const textout = pruner(textin);
				if ( textout === textin ) { return; }
				Object.defineProperty(thisArg, 'response', { value: textout });
				Object.defineProperty(thisArg, 'responseText', { value: textout });
				if ( toLog.length !== 0 ) {
					toLog.unshift(logPrefix);
					log(toLog.join('\n'));
				}
			});
			return Reflect.apply(target, thisArg, args);
		}
	});
}


# https://github.com/uBlockOrigin/uAssets/issues/521
# https://github.com/uBlockOrigin/uAssets/issues/9123#issuecomment-848255120
addEventListener-defuser.js application/javascript
alias aeld.js
alias prevent-addEventListener.js
function(type, pattern) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Function_toStringFn': self.Function.prototype.toString,
			'Function_toString': thisArg => safe.Function_toStringFn.call(thisArg),
			'Object_fromEntries': Object.fromEntries.bind(Object),
			'RegExp_test': self.RegExp.prototype.test,
			'addEventListener': self.EventTarget.prototype.addEventListener,
			'removeEventListener': self.EventTarget.prototype.removeEventListener,
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function shouldDebug(details) {
		if ( details instanceof Object === false ) { return false; }
		return details.debug;
	}
	function runAt(fn, when) {
		const intFromReadyState = state => {
			const targets = {
				'loading': 1,
				'interactive': 2, 'end': 2, '2': 2,
				'complete': 3, 'idle': 3, '3': 3,
			};
			const tokens = Array.isArray(state) ? state : [ state ];
			for ( const token of tokens ) {
				const prop = `${token}`;
				if ( targets.hasOwnProperty(prop) === false ) { continue; }
				return targets[prop];
			}
			return 0;
		};
		const runAt = intFromReadyState(when);
		if ( intFromReadyState(document.readyState) >= runAt ) {
			fn(); return;
		}
		const onStateChange = ( ) => {
			if ( intFromReadyState(document.readyState) < runAt ) { return; }
			fn();
			safe.removeEventListener.apply(document, args);
		};
		const safe = safeSelf();
		const args = [ 'readystatechange', onStateChange, { capture: true } ];
		safe.addEventListener.apply(document, args);
	}
	if ( type === undefined ) { type = ''; }
	if ( pattern === undefined ) { pattern = ''; }
	const safe = safeSelf();
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 2);
	const log = console.log.bind(console, makeLogPrefix('prevent-addEventListener', type, pattern));
	const reType = safe.patternToRegex(type, undefined, true);
	const rePattern = safe.patternToRegex(pattern);
	const debug = shouldDebug(extraArgs);
	const targetSelector = extraArgs.elements || undefined;
	const elementMatches = elem => {
		if ( elem && elem.matches && elem.matches(targetSelector) ) { return true; }
		const elems = Array.from(document.querySelectorAll(targetSelector));
		return elems.includes(elem);
	};
	const elementDetails = elem => {
		if ( elem instanceof Window ) { return 'window'; }
		if ( elem instanceof Document ) { return 'document'; }
		if ( elem instanceof Element === false ) { return '?'; }
		const parts = [];
		if ( elem.id !== '' ) { parts.push(`#${CSS.escape(elem.id)}`); }
		for ( let i = 0; i < elem.classList.length; i++ ) {
			parts.push(`.${CSS.escape(elem.classList.item(i))}`);
		}
		for ( let i = 0; i < elem.attributes.length; i++ ) {
			const attr = elem.attributes.item(i);
			if ( attr.name === 'id' ) { continue; }
			if ( attr.name === 'class' ) { continue; }
			parts.push(`[${CSS.escape(attr.name)}="${attr.value}"]`);
		}
		return parts.join('');
	};
	const shouldPrevent = (thisArg, type, handler) => {
		const matchesType = safe.RegExp_test.call(reType, type);
		const matchesHandler = safe.RegExp_test.call(rePattern, handler);
		const matchesEither = matchesType || matchesHandler;
		const matchesBoth = matchesType && matchesHandler;
		if ( debug === 1 && matchesBoth || debug === 2 && matchesEither ) {
			debugger; // jshint ignore:line
		}
		if ( matchesBoth && targetSelector !== undefined ) {
			if ( elementMatches(thisArg) === false ) { return false; }
		}
		return matchesBoth;
	};
	const trapEddEventListeners = ( ) => {
		const eventListenerHandler = {
			apply: function(target, thisArg, args) {
				let t, h;
				try {
					t = String(args[0]);
					if ( typeof args[1] === 'function' ) {
						h = String(safe.Function_toString(args[1]));
					} else if ( typeof args[1] === 'object' && args[1] !== null ) {
						if ( typeof args[1].handleEvent === 'function' ) {
							h = String(safe.Function_toString(args[1]));
						}
					} else {
						h = String(args[1]);
					}
				} catch(ex) {
				}
				if ( type === '' && pattern === '' ) {
					log(`Called: ${t}\n${h}\n${elementDetails(thisArg)}`);
				} else if ( shouldPrevent(thisArg, t, h) ) {
					return log(`Prevented: ${t}\n${h}\n${elementDetails(thisArg)}`);
				}
				return Reflect.apply(target, thisArg, args);
			},
			get(target, prop, receiver) {
				if ( prop === 'toString' ) {
					return target.toString.bind(target);
				}
				return Reflect.get(target, prop, receiver);
			},
		};
		self.EventTarget.prototype.addEventListener = new Proxy(
			self.EventTarget.prototype.addEventListener,
			eventListenerHandler
		);
	};
	runAt(( ) => {
		trapEddEventListeners();
	}, extraArgs.runAt);
}


# https://github.com/uBlockOrigin/uAssets/issues/618
abort-current-script.js application/javascript
alias acs.js
alias abort-current-inline-script.js
alias acis.js
function(target, needle, context) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Object_fromEntries': Object.fromEntries.bind(Object),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function runAtHtmlElementFn(fn) {
		if ( document.documentElement ) {
			fn();
			return;
		}
		const observer = new MutationObserver(( ) => {
			observer.disconnect();
			fn();
		});
		observer.observe(document, { childList: true });
	}
	function shouldDebug(details) {
		if ( details instanceof Object === false ) { return false; }
		return details.debug;
	}
	// Issues to mind before changing anything:
	// https://github.com/uBlockOrigin/uBlock-issues/issues/2154
	function abortCurrentScriptCore(
		target = '',
		needle = '',
		context = ''
	) {
		if ( target === '' ) { return; }
		const safe = safeSelf();
		const logPrefix = makeLogPrefix('abort-current-script', target, needle, context);
		const log = console.log.bind(console, logPrefix);
		const logErr = console.error.bind(console, logPrefix);
		const reNeedle = safe.patternToRegex(needle);
		const reContext = safe.patternToRegex(context);
		const extraArgs = safe.getExtraArgs(Array.from(arguments), 3);
		const thisScript = document.currentScript;
		const chain = target.split('.');
		let owner = window;
		let prop;
		for (;;) {
			prop = chain.shift();
			if ( chain.length === 0 ) { break; }
			if ( prop in owner === false ) { break; }
			owner = owner[prop];
			if ( owner instanceof Object === false ) { return; }
		}
		let value;
		let desc = Object.getOwnPropertyDescriptor(owner, prop);
		if (
			desc instanceof Object === false ||
			desc.get instanceof Function === false
		) {
			value = owner[prop];
			desc = undefined;
		}
		const debug = shouldDebug(extraArgs);
		const exceptionToken = getExceptionToken();
		const scriptTexts = new WeakMap();
		const getScriptText = elem => {
			let text = elem.textContent;
			if ( text.trim() !== '' ) { return text; }
			if ( scriptTexts.has(elem) ) { return scriptTexts.get(elem); }
			const [ , mime, content ] =
				/^data:([^,]*),(.+)$/.exec(elem.src.trim()) ||
				[ '', '', '' ];
			try {
				switch ( true ) {
				case mime.endsWith(';base64'):
					text = atob(content);
					break;
				default:
					text = decodeURIComponent(content);
					break;
				}
			} catch(ex) {
			}
			scriptTexts.set(elem, text);
			return text;
		};
		const validate = ( ) => {
			const e = document.currentScript;
			if ( e instanceof HTMLScriptElement === false ) { return; }
			if ( e === thisScript ) { return; }
			if ( context !== '' && reContext.test(e.src) === false ) {
				if ( debug === 'nomatch' || debug === 'all' ) { debugger; }  // jshint ignore: line
				return;
			}
			if ( extraArgs.scriptletLogLevel > 1 && context !== '' ) {
				log(`Matched src\n${e.src}`);
			}
			const scriptText = getScriptText(e);
			if ( reNeedle.test(scriptText) === false ) {
				if ( debug === 'nomatch' || debug === 'all' ) { debugger; }  // jshint ignore: line
				return;
			}
			if ( extraArgs.scriptletLogLevel > 1 ) {
				log(`Matched text\n${scriptText}`);
			}
			if ( debug === 'match' || debug === 'all' ) { debugger; }  // jshint ignore: line
			log('Aborted');
			throw new ReferenceError(exceptionToken);
		};
		if ( debug === 'install' ) { debugger; }  // jshint ignore: line
		try {
			Object.defineProperty(owner, prop, {
				get: function() {
					validate();
					return desc instanceof Object
						? desc.get.call(owner)
						: value;
				},
				set: function(a) {
					validate();
					if ( desc instanceof Object ) {
						desc.set.call(owner, a);
					} else {
						value = a;
					}
				}
			});
		} catch(ex) {
			logErr(`Error: ${ex}`);
		}
	}
	runAtHtmlElementFn(( ) => {
		abortCurrentScriptCore(...arguments);
	});
}


# https://github.com/gorhill/uBlock/commit/b27848a060eee961e2403192097448467b3bc7b5
no-window-open-if.js application/javascript
alias nowoif.js
alias prevent-window-open.js
alias window.open-defuser.js
function(pattern, delay, decoy) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Object_fromEntries': Object.fromEntries.bind(Object),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	if ( pattern === undefined ) { pattern = ''; }
	if ( delay === undefined ) { delay = ''; }
	if ( decoy === undefined ) { decoy = ''; }
	const safe = safeSelf();
	const log = console.log.bind(console, makeLogPrefix('no-window-open-if', pattern, delay, decoy));
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 3);
	const targetMatchResult = pattern.startsWith('!') === false;
	if ( targetMatchResult === false ) {
		pattern = pattern.slice(1);
	}
	const rePattern = safe.patternToRegex(pattern);
	let autoRemoveAfter = parseInt(delay);
	if ( isNaN(autoRemoveAfter) ) {
		autoRemoveAfter = -1;
	}
	const createDecoy = function(tag, urlProp, url) {
		const decoyElem = document.createElement(tag);
		decoyElem[urlProp] = url;
		decoyElem.style.setProperty('height','1px', 'important');
		decoyElem.style.setProperty('position','fixed', 'important');
		decoyElem.style.setProperty('top','-1px', 'important');
		decoyElem.style.setProperty('width','1px', 'important');
		document.body.appendChild(decoyElem);
		setTimeout(( ) => { decoyElem.remove(); }, autoRemoveAfter * 1000);
		return decoyElem;
	};
	window.open = new Proxy(window.open, {
		apply: function(target, thisArg, args) {
			const haystack = args.join(' ');
			if ( rePattern.test(haystack) !== targetMatchResult ) {
				if ( extraArgs.scriptletLogLevel > 1 ) {
					log(`Allowed (${args.join(', ')})`);
				}
				return Reflect.apply(target, thisArg, args);
			}
			log(`Prevented (${args.join(', ')})`);
			if ( autoRemoveAfter < 0 ) { return null; }
			const decoyElem = decoy === 'obj'
				? createDecoy('object', 'data', ...args)
				: createDecoy('iframe', 'src', ...args);
			let popup = decoyElem.contentWindow;
			if ( typeof popup === 'object' && popup !== null ) {
				Object.defineProperty(popup, 'closed', { value: false });
			} else {
				const noopFunc = (function(){}).bind(self);
				popup = new Proxy(self, {
					get: function(target, prop) {
						if ( prop === 'closed' ) { return false; }
						const r = Reflect.get(...arguments);
						if ( typeof r === 'function' ) { return noopFunc; }
						return target[prop];
					},
					set: function() {
						return Reflect.set(...arguments);
					},
				});
			}
			if ( extraArgs.scriptletLogLevel > 0 ) {
				popup = new Proxy(popup, {
					get: function(target, prop) {
						log('window.open / get', prop, '===', target[prop]);
						return Reflect.get(...arguments);
					},
					set: function(target, prop, value) {
						log('window.open / set', prop, '=', value);
						return Reflect.set(...arguments);
					},
				});
			}
			return popup;
		}
	});
}


# https://github.com/uBlockOrigin/uAssets/issues/10323#issuecomment-992312847
# https://github.com/AdguardTeam/Scriptlets/issues/158
# https://github.com/uBlockOrigin/uBlock-issues/discussions/2270
close-window.js application/javascript
alias window-close-if.js
function(arg1) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	if ( arg1 === undefined ) { arg1 = ''; }
	const safe = safeSelf();
	let subject = '';
	if ( /^\/.*\/$/.test(arg1) ) {
		subject = window.location.href;
	} else if ( arg1 !== '' ) {
		subject = `${window.location.pathname}${window.location.search}`;
	}
	try {
		const re = safe.patternToRegex(arg1);
		if ( re.test(subject) ) {
			window.close();
		}
	} catch(ex) {
		console.log(ex);
	}
}


# https://github.com/uBlockOrigin/uAssets/issues/913
disable-newtab-links.js application/javascript
(function() {
	'use strict';
	document.addEventListener('click', function(ev) {
		let target = ev.target;
		while ( target !== null ) {
			if ( target.localName === 'a' && target.hasAttribute('target') ) {
				ev.stopPropagation();
				ev.preventDefault();
				break;
			}
			target = target.parentNode;
		}
	});
})();


set-constant.js application/javascript
alias set.js
function(chain, rawValue) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Object': Object,
			'Object_defineProperty': Object.defineProperty.bind(Object),
			'Object_fromEntries': Object.fromEntries.bind(Object),
			'Object_getOwnPropertyDescriptor': Object.getOwnPropertyDescriptor.bind(Object),
			'addEventListener': self.EventTarget.prototype.addEventListener,
			'removeEventListener': self.EventTarget.prototype.removeEventListener,
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function validateConstantFn(raw) {
		const safe = safeSelf();
		const extraArgs = safe.getExtraArgs(Array.from(arguments), 1);
		let value;
		if ( raw === 'undefined' ) {
			value = undefined;
		} else if ( raw === 'false' ) {
			value = false;
		} else if ( raw === 'true' ) {
			value = true;
		} else if ( raw === 'null' ) {
			value = null;
		} else if ( raw === "''" || raw === '' ) {
			value = '';
		} else if ( raw === '[]' || raw === 'emptyArr' ) {
			value = [];
		} else if ( raw === '{}' || raw === 'emptyObj' ) {
			value = {};
		} else if ( raw === 'noopFunc' ) {
			value = function(){};
		} else if ( raw === 'trueFunc' ) {
			value = function(){ return true; };
		} else if ( raw === 'falseFunc' ) {
			value = function(){ return false; };
		} else if ( /^-?\d+$/.test(raw) ) {
			value = parseInt(raw);
			if ( isNaN(raw) ) { return; }
			if ( Math.abs(raw) > 0x7FFF ) { return; }
		} else {
			return;
		}
		if ( extraArgs.as !== undefined ) {
			if ( extraArgs.as === 'function' ) {
				return ( ) => value;
			} else if ( extraArgs.as === 'callback' ) {
				return ( ) => (( ) => value);
			} else if ( extraArgs.as === 'resolved' ) {
				return Promise.resolve(value);
			} else if ( extraArgs.as === 'rejected' ) {
				return Promise.reject(value);
			}
		}
		return value;
	}
	function runAt(fn, when) {
		const intFromReadyState = state => {
			const targets = {
				'loading': 1,
				'interactive': 2, 'end': 2, '2': 2,
				'complete': 3, 'idle': 3, '3': 3,
			};
			const tokens = Array.isArray(state) ? state : [ state ];
			for ( const token of tokens ) {
				const prop = `${token}`;
				if ( targets.hasOwnProperty(prop) === false ) { continue; }
				return targets[prop];
			}
			return 0;
		};
		const runAt = intFromReadyState(when);
		if ( intFromReadyState(document.readyState) >= runAt ) {
			fn(); return;
		}
		const onStateChange = ( ) => {
			if ( intFromReadyState(document.readyState) < runAt ) { return; }
			fn();
			safe.removeEventListener.apply(document, args);
		};
		const safe = safeSelf();
		const args = [ 'readystatechange', onStateChange, { capture: true } ];
		safe.addEventListener.apply(document, args);
	}
	if ( chain === undefined || chain === '' ) { return; }
	if ( rawValue === undefined ) { rawValue = ''; }
	const safe = safeSelf();
	const logPrefix = makeLogPrefix('set-constant', chain, rawValue);
	const log = console.log.bind(console, logPrefix);
	const logErr = console.error.bind(console, logPrefix);
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 2);
	function setConstant(chain, rawValue) {
		const trappedProp = (( ) => {
			const pos = chain.lastIndexOf('.');
			if ( pos === -1 ) { return chain; }
			return chain.slice(pos+1);
		})();
		const cloakFunc = fn => {
			safe.Object_defineProperty(fn, 'name', { value: trappedProp });
			return new Proxy(fn, {
				defineProperty(target, prop) {
					if ( prop !== 'toString' ) {
						return Reflect.defineProperty(...arguments);
					}
					return true;
				},
				deleteProperty(target, prop) {
					if ( prop !== 'toString' ) {
						return Reflect.deleteProperty(...arguments);
					}
					return true;
				},
				get(target, prop) {
					if ( prop === 'toString' ) {
						return function() {
							return `function ${trappedProp}() { [native code] }`;
						}.bind(null);
					}
					return Reflect.get(...arguments);
				},
			});
		};
		if ( trappedProp === '' ) { return; }
		const thisScript = document.currentScript;
		let normalValue = validateConstantFn(rawValue);
		if ( rawValue === 'noopFunc' || rawValue === 'trueFunc' || rawValue === 'falseFunc' ) {
			normalValue = cloakFunc(normalValue);
		}
		let aborted = false;
		const mustAbort = function(v) {
			if ( aborted ) { return true; }
			aborted =
				(v !== undefined && v !== null) &&
				(normalValue !== undefined && normalValue !== null) &&
				(typeof v !== typeof normalValue);
			if ( aborted ) {
				log(`Aborted because value set to ${v}`);
			}
			return aborted;
		};
		// https://github.com/uBlockOrigin/uBlock-issues/issues/156
		//   Support multiple trappers for the same property.
		const trapProp = function(owner, prop, configurable, handler) {
			if ( handler.init(configurable ? owner[prop] : normalValue) === false ) { return; }
			const odesc = safe.Object_getOwnPropertyDescriptor(owner, prop);
			let prevGetter, prevSetter;
			if ( odesc instanceof safe.Object ) {
				owner[prop] = normalValue;
				if ( odesc.get instanceof Function ) {
					prevGetter = odesc.get;
				}
				if ( odesc.set instanceof Function ) {
					prevSetter = odesc.set;
				}
			}
			try {
				safe.Object_defineProperty(owner, prop, {
					configurable,
					get() {
						if ( prevGetter !== undefined ) {
							prevGetter();
						}
						return handler.getter();
					},
					set(a) {
						if ( prevSetter !== undefined ) {
							prevSetter(a);
						}
						handler.setter(a);
					}
				});
				log('Trap installed');
			} catch(ex) {
				logErr(ex);
			}
		};
		const trapChain = function(owner, chain) {
			const pos = chain.indexOf('.');
			if ( pos === -1 ) {
				trapProp(owner, chain, false, {
					v: undefined,
					init: function(v) {
						if ( mustAbort(v) ) { return false; }
						this.v = v;
						return true;
					},
					getter: function() {
						if ( document.currentScript === thisScript ) {
							return this.v;
						}
						log('Property read');
						return normalValue;
					},
					setter: function(a) {
						if ( mustAbort(a) === false ) { return; }
						normalValue = a;
					}
				});
				return;
			}
			const prop = chain.slice(0, pos);
			const v = owner[prop];
			chain = chain.slice(pos + 1);
			if ( v instanceof safe.Object || typeof v === 'object' && v !== null ) {
				trapChain(v, chain);
				return;
			}
			trapProp(owner, prop, true, {
				v: undefined,
				init: function(v) {
					this.v = v;
					return true;
				},
				getter: function() {
					return this.v;
				},
				setter: function(a) {
					this.v = a;
					if ( a instanceof safe.Object ) {
						trapChain(a, chain);
					}
				}
			});
		};
		trapChain(window, chain);
	}
	runAt(( ) => {
		setConstant(chain, rawValue);
	}, extraArgs.runAt);
}


trusted-set-constant.js application/javascript
alias trusted-set.js
function(chain, rawValue) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Object': Object,
			'Object_defineProperty': Object.defineProperty.bind(Object),
			'Object_fromEntries': Object.fromEntries.bind(Object),
			'Object_getOwnPropertyDescriptor': Object.getOwnPropertyDescriptor.bind(Object),
			'addEventListener': self.EventTarget.prototype.addEventListener,
			'removeEventListener': self.EventTarget.prototype.removeEventListener,
			'JSON': self.JSON,
			'JSON_parseFn': self.JSON.parse,
			'JSON_parse': (...args) => safe.JSON_parseFn.call(safe.JSON, ...args),
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function validateConstantFn(raw) {
		const safe = safeSelf();
		const extraArgs = safe.getExtraArgs(Array.from(arguments), 1);
		let value;
		if ( raw === 'undefined' ) {
			value = undefined;
		} else if ( raw === 'false' ) {
			value = false;
		} else if ( raw === 'true' ) {
			value = true;
		} else if ( raw === 'null' ) {
			value = null;
		} else if ( raw === "''" || raw === '' ) {
			value = '';
		} else if ( raw === '[]' || raw === 'emptyArr' ) {
			value = [];
		} else if ( raw === '{}' || raw === 'emptyObj' ) {
			value = {};
		} else if ( raw === 'noopFunc' ) {
			value = function(){};
		} else if ( raw === 'trueFunc' ) {
			value = function(){ return true; };
		} else if ( raw === 'falseFunc' ) {
			value = function(){ return false; };
		} else if ( /^-?\d+$/.test(raw) ) {
			value = parseInt(raw);
			if ( isNaN(raw) ) { return; }
			if ( Math.abs(raw) > 0x7FFF ) { return; }
		} else {
			if ( raw.startsWith('{') && raw.endsWith('}') ) {
				try { value = safe.JSON_parse(raw).value; } catch(ex) { return; }
			}
		}
		if ( extraArgs.as !== undefined ) {
			if ( extraArgs.as === 'function' ) {
				return ( ) => value;
			} else if ( extraArgs.as === 'callback' ) {
				return ( ) => (( ) => value);
			} else if ( extraArgs.as === 'resolved' ) {
				return Promise.resolve(value);
			} else if ( extraArgs.as === 'rejected' ) {
				return Promise.reject(value);
			}
		}
		return value;
	}
	function runAt(fn, when) {
		const intFromReadyState = state => {
			const targets = {
				'loading': 1,
				'interactive': 2, 'end': 2, '2': 2,
				'complete': 3, 'idle': 3, '3': 3,
			};
			const tokens = Array.isArray(state) ? state : [ state ];
			for ( const token of tokens ) {
				const prop = `${token}`;
				if ( targets.hasOwnProperty(prop) === false ) { continue; }
				return targets[prop];
			}
			return 0;
		};
		const runAt = intFromReadyState(when);
		if ( intFromReadyState(document.readyState) >= runAt ) {
			fn(); return;
		}
		const onStateChange = ( ) => {
			if ( intFromReadyState(document.readyState) < runAt ) { return; }
			fn();
			safe.removeEventListener.apply(document, args);
		};
		const safe = safeSelf();
		const args = [ 'readystatechange', onStateChange, { capture: true } ];
		safe.addEventListener.apply(document, args);
	}
	if ( chain === undefined || chain === '' ) { return; }
	if ( rawValue === undefined ) { rawValue = ''; }
	const safe = safeSelf();
	const logPrefix = makeLogPrefix('trusted-set-constant', chain, rawValue);
	const log = console.log.bind(console, logPrefix);
	const logErr = console.error.bind(console, logPrefix);
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 2);
	function setConstant(chain, rawValue) {
		const trappedProp = (( ) => {
			const pos = chain.lastIndexOf('.');
			if ( pos === -1 ) { return chain; }
			return chain.slice(pos+1);
		})();
		const cloakFunc = fn => {
			safe.Object_defineProperty(fn, 'name', { value: trappedProp });
			return new Proxy(fn, {
				defineProperty(target, prop) {
					if ( prop !== 'toString' ) {
						return Reflect.defineProperty(...arguments);
					}
					return true;
				},
				deleteProperty(target, prop) {
					if ( prop !== 'toString' ) {
						return Reflect.deleteProperty(...arguments);
					}
					return true;
				},
				get(target, prop) {
					if ( prop === 'toString' ) {
						return function() {
							return `function ${trappedProp}() { [native code] }`;
						}.bind(null);
					}
					return Reflect.get(...arguments);
				},
			});
		};
		if ( trappedProp === '' ) { return; }
		const thisScript = document.currentScript;
		let normalValue = validateConstantFn(rawValue);
		if ( rawValue === 'noopFunc' || rawValue === 'trueFunc' || rawValue === 'falseFunc' ) {
			normalValue = cloakFunc(normalValue);
		}
		const mustAbort = function(v) {
			return false;
		};
		// https://github.com/uBlockOrigin/uBlock-issues/issues/156
		//   Support multiple trappers for the same property.
		const trapProp = function(owner, prop, configurable, handler) {
			if ( handler.init(configurable ? owner[prop] : normalValue) === false ) { return; }
			const odesc = safe.Object_getOwnPropertyDescriptor(owner, prop);
			let prevGetter, prevSetter;
			if ( odesc instanceof safe.Object ) {
				owner[prop] = normalValue;
				if ( odesc.get instanceof Function ) {
					prevGetter = odesc.get;
				}
				if ( odesc.set instanceof Function ) {
					prevSetter = odesc.set;
				}
			}
			try {
				safe.Object_defineProperty(owner, prop, {
					configurable,
					get() {
						if ( prevGetter !== undefined ) {
							prevGetter();
						}
						return handler.getter();
					},
					set(a) {
						if ( prevSetter !== undefined ) {
							prevSetter(a);
						}
						handler.setter(a);
					}
				});
				log('Trap installed');
			} catch(ex) {
				logErr(ex);
			}
		};
		const trapChain = function(owner, chain) {
			const pos = chain.indexOf('.');
			if ( pos === -1 ) {
				trapProp(owner, chain, false, {
					v: undefined,
					init: function(v) {
						if ( mustAbort(v) ) { return false; }
						this.v = v;
						return true;
					},
					getter: function() {
						if ( document.currentScript === thisScript ) {
							return this.v;
						}
						log('Property read');
						return normalValue;
					},
					setter: function(a) {
						if ( mustAbort(a) === false ) { return; }
						normalValue = a;
					}
				});
				return;
			}
			const prop = chain.slice(0, pos);
			const v = owner[prop];
			chain = chain.slice(pos + 1);
			if ( v instanceof safe.Object || typeof v === 'object' && v !== null ) {
				trapChain(v, chain);
				return;
			}
			trapProp(owner, prop, true, {
				v: undefined,
				init: function(v) {
					this.v = v;
					return true;
				},
				getter: function() {
					return this.v;
				},
				setter: function(a) {
					this.v = a;
					if ( a instanceof safe.Object ) {
						trapChain(a, chain);
					}
				}
			});
		};
		trapChain(window, chain);
	}
	runAt(( ) => {
		setConstant(chain, rawValue);
	}, extraArgs.runAt);
}


set-cookie.js application/javascript
function(name, value, path) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Object_fromEntries': Object.fromEntries.bind(Object),
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function getCookieFn(
		name = ''
	) {
		for ( const s of document.cookie.split(/\s*;\s*/) ) {
			const pos = s.indexOf('=');
			if ( pos === -1 ) { continue; }
			if ( s.slice(0, pos) !== name ) { continue; }
			return s.slice(pos+1).trim();
		}
	}
	function setCookieFn(
		name = '',
		value = '',
		expires = '',
		path = '',
		options = {},
	) {
		// https://datatracker.ietf.org/doc/html/rfc2616#section-2.2
		// https://github.com/uBlockOrigin/uBlock-issues/issues/2777
		if ( /[^!#$%&'*+\-.0-9A-Z[\]^_`a-z|~]/.test(name) ) {
			name = encodeURIComponent(name);
		}
		// https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1
		// The characters [",] are given a pass from the RFC requirements because
		// apparently browsers do not follow the RFC to the letter.
		if ( /[^ -:<-[\]-~]/.test(value) ) {
			value = encodeURIComponent(value);
		}
		const cookieBefore = getCookieFn(name);
		if ( cookieBefore !== undefined && options.dontOverwrite ) { return; }
		if ( cookieBefore === value && options.reload ) { return; }
		const cookieParts = [ name, '=', value ];
		if ( expires !== '' ) {
			cookieParts.push('; expires=', expires);
		}
		if ( path === '' ) { path = '/'; }
		else if ( path === 'none' ) { path = ''; }
		if ( path !== '' && path !== '/' ) { return; }
		if ( path === '/' ) {
			cookieParts.push('; path=/');
		}
		try {
			document.cookie = cookieParts.join('');
		} catch(_) {
		}
		const done = getCookieFn(name) === value;
		if ( done && options.reload ) {
			window.location.reload();
		}
		return done;
	}
	if ( name === undefined || name === '' ) { return; }
	if ( value === undefined || value === '' ) { return; }
	if ( path === undefined ) { path = ''; }
	const safe = safeSelf();
	const log = console.log.bind(console, makeLogPrefix('set-cookie', name, value, path));
	const validValues = [
		'accept', 'reject',
		'accepted', 'rejected', 'notaccepted',
		'allow', 'deny',
		'allowed', 'disallow',
		'enable', 'disable',
		'enabled', 'disabled',
		'ok',
		'on', 'off',
		'true', 't', 'false', 'f',
		'yes', 'y', 'no', 'n',
		'necessary', 'required',
	];
	const normalized = value.toLowerCase();
	const match = /^("?)(.+)\1$/.exec(normalized);
	const unquoted = match && match[2] || normalized;
	if ( validValues.includes(unquoted) === false ) {
		if ( /^\d+$/.test(unquoted) === false ) { return; }
		const n = parseInt(value, 10);
		if ( n > 32767 ) { return; }
	}
	const done = setCookieFn(
		name,
		value,
		'',
		path,
		safe.getExtraArgs(Array.from(arguments), 3)
	);
	if ( done ) {
		log('Done');
	}
}


trusted-set-cookie.js application/javascript
function(name, value, offsetExpiresSec, path) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Object_fromEntries': Object.fromEntries.bind(Object),
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function getCookieFn(
		name = ''
	) {
		for ( const s of document.cookie.split(/\s*;\s*/) ) {
			const pos = s.indexOf('=');
			if ( pos === -1 ) { continue; }
			if ( s.slice(0, pos) !== name ) { continue; }
			return s.slice(pos+1).trim();
		}
	}
	function setCookieFn(
		name = '',
		value = '',
		expires = '',
		path = '',
		options = {},
	) {
		// https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1
		// The characters [",] are given a pass from the RFC requirements because
		// apparently browsers do not follow the RFC to the letter.
		if ( /[^ -:<-[\]-~]/.test(value) ) {
			value = encodeURIComponent(value);
		}
		const cookieBefore = getCookieFn(name);
		if ( cookieBefore !== undefined && options.dontOverwrite ) { return; }
		if ( cookieBefore === value && options.reload ) { return; }
		const cookieParts = [ name, '=', value ];
		if ( expires !== '' ) {
			cookieParts.push('; expires=', expires);
		}
		if ( path === '' ) { path = '/'; }
		else if ( path === 'none' ) { path = ''; }
		if ( path !== '' && path !== '/' ) { return; }
		if ( path === '/' ) {
			cookieParts.push('; path=/');
		}
		if ( options.domain ) {
			cookieParts.push(`; domain=${options.domain}`);
		}
		cookieParts.push('; Secure');
		try {
			document.cookie = cookieParts.join('');
		} catch(_) {
		}
		const done = getCookieFn(name) === value;
		if ( done && options.reload ) {
			window.location.reload();
		}
		return done;
	}
	if ( name === undefined || name === '' ) { return; }
	if ( value === undefined || value === '' ) { return; }
	if ( offsetExpiresSec === undefined ) { offsetExpiresSec = ''; }
	if ( path === undefined ) { path = ''; }
	const safe = safeSelf();
	const log = console.log.bind(console, makeLogPrefix('trusted-set-cookie', name, value, path));
	const time = new Date();
	if ( value === '$now$' ) {
		value = Date.now();
	} else if ( value === '$currentDate$' ) {
		value = time.toUTCString();
	}
	let expires = '';
	if ( offsetExpiresSec !== '' ) {
		if ( offsetExpiresSec === '1day' ) {
			time.setDate(time.getDate() + 1);
		} else if ( offsetExpiresSec === '1year' ) {
			time.setFullYear(time.getFullYear() + 1);
		} else {
			if ( /^\d+$/.test(offsetExpiresSec) === false ) { return; }
			time.setSeconds(time.getSeconds() + parseInt(offsetExpiresSec, 10));
		}
		expires = time.toUTCString();
	}
	const done = setCookieFn(
		name,
		value,
		expires,
		path,
		safe.getExtraArgs(Array.from(arguments), 4)
	);
	if ( done ) {
		log('Done');
	}
}


set-cookie-reload.js application/javascript
function(name, value, path) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Object_fromEntries': Object.fromEntries.bind(Object),
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function getCookieFn(
		name = ''
	) {
		for ( const s of document.cookie.split(/\s*;\s*/) ) {
			const pos = s.indexOf('=');
			if ( pos === -1 ) { continue; }
			if ( s.slice(0, pos) !== name ) { continue; }
			return s.slice(pos+1).trim();
		}
	}
	function setCookieFn(
		name = '',
		value = '',
		expires = '',
		path = '',
		options = {},
	) {
		// https://datatracker.ietf.org/doc/html/rfc2616#section-2.2
		// https://github.com/uBlockOrigin/uBlock-issues/issues/2777
		if ( /[^!#$%&'*+\-.0-9A-Z[\]^_`a-z|~]/.test(name) ) {
			name = encodeURIComponent(name);
		}
		// https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1
		// The characters [",] are given a pass from the RFC requirements because
		// apparently browsers do not follow the RFC to the letter.
		if ( /[^ -:<-[\]-~]/.test(value) ) {
			value = encodeURIComponent(value);
		}
		const cookieBefore = getCookieFn(name);
		if ( cookieBefore !== undefined && options.dontOverwrite ) { return; }
		if ( cookieBefore === value && options.reload ) { return; }
		const cookieParts = [ name, '=', value ];
		if ( expires !== '' ) {
			cookieParts.push('; expires=', expires);
		}
		if ( path === '' ) { path = '/'; }
		else if ( path === 'none' ) { path = ''; }
		if ( path !== '' && path !== '/' ) { return; }
		if ( path === '/' ) {
			cookieParts.push('; path=/');
		}
		try {
			document.cookie = cookieParts.join('');
		} catch(_) {
		}
		const done = getCookieFn(name) === value;
		if ( done && options.reload ) {
			window.location.reload();
		}
		return done;
	}
	if ( name === undefined || name === '' ) { return; }
	if ( value === undefined || value === '' ) { return; }
	if ( path === undefined ) { path = ''; }
	const safe = safeSelf();
	const log = console.log.bind(console, makeLogPrefix('set-cookie-reload', name, value, path));
	const validValues = [
		'accept', 'reject',
		'accepted', 'rejected', 'notaccepted',
		'allow', 'deny',
		'allowed', 'disallow',
		'enable', 'disable',
		'enabled', 'disabled',
		'ok',
		'on', 'off',
		'true', 't', 'false', 'f',
		'yes', 'y', 'no', 'n',
		'necessary', 'required',
	];
	const normalized = value.toLowerCase();
	const match = /^("?)(.+)\1$/.exec(normalized);
	const unquoted = match && match[2] || normalized;
	if ( validValues.includes(unquoted) === false ) {
		if ( /^\d+$/.test(unquoted) === false ) { return; }
		const n = parseInt(value, 10);
		if ( n > 32767 ) { return; }
	}
	const done = setCookieFn(
		name,
		value,
		'',
		path,
		safe.getExtraArgs(Array.from(arguments).concat([ 'reload', '1' ]), 3)
	);
	if ( done ) {
		log('Done');
	}
}


trusted-set-cookie-reload.js application/javascript
function(name, value, offsetExpiresSec, path) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Object_fromEntries': Object.fromEntries.bind(Object),
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function getCookieFn(
		name = ''
	) {
		for ( const s of document.cookie.split(/\s*;\s*/) ) {
			const pos = s.indexOf('=');
			if ( pos === -1 ) { continue; }
			if ( s.slice(0, pos) !== name ) { continue; }
			return s.slice(pos+1).trim();
		}
	}
	function setCookieFn(
		name = '',
		value = '',
		expires = '',
		path = '',
		options = {},
	) {
		// https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1
		// The characters [",] are given a pass from the RFC requirements because
		// apparently browsers do not follow the RFC to the letter.
		if ( /[^ -:<-[\]-~]/.test(value) ) {
			value = encodeURIComponent(value);
		}
		const cookieBefore = getCookieFn(name);
		if ( cookieBefore !== undefined && options.dontOverwrite ) { return; }
		if ( cookieBefore === value && options.reload ) { return; }
		const cookieParts = [ name, '=', value ];
		if ( expires !== '' ) {
			cookieParts.push('; expires=', expires);
		}
		if ( path === '' ) { path = '/'; }
		else if ( path === 'none' ) { path = ''; }
		if ( path !== '' && path !== '/' ) { return; }
		if ( path === '/' ) {
			cookieParts.push('; path=/');
		}
		if ( options.domain ) {
			cookieParts.push(`; domain=${options.domain}`);
		}
		cookieParts.push('; Secure');
		try {
			document.cookie = cookieParts.join('');
		} catch(_) {
		}
		const done = getCookieFn(name) === value;
		if ( done && options.reload ) {
			window.location.reload();
		}
		return done;
	}
	if ( name === undefined || name === '' ) { return; }
	if ( value === undefined || value === '' ) { return; }
	if ( offsetExpiresSec === undefined ) { offsetExpiresSec = ''; }
	if ( path === undefined ) { path = ''; }
	const safe = safeSelf();
	const log = console.log.bind(console, makeLogPrefix('trusted-set-cookie-reload', name, value, path));
	const time = new Date();
	if ( value === '$now$' ) {
		value = Date.now();
	} else if ( value === '$currentDate$' ) {
		value = time.toUTCString();
	}
	let expires = '';
	if ( offsetExpiresSec !== '' ) {
		if ( offsetExpiresSec === '1day' ) {
			time.setDate(time.getDate() + 1);
		} else if ( offsetExpiresSec === '1year' ) {
			time.setFullYear(time.getFullYear() + 1);
		} else {
			if ( /^\d+$/.test(offsetExpiresSec) === false ) { return; }
			time.setSeconds(time.getSeconds() + parseInt(offsetExpiresSec, 10));
		}
		expires = time.toUTCString();
	}
	const done = setCookieFn(
		name,
		value,
		expires,
		path,
		safe.getExtraArgs(Array.from(arguments).concat([ 'reload', '1' ]), 4)
	);
	if ( done ) {
		log('Done');
	}
}


set-local-storage-item.js application/javascript
function(key, value) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	if ( key === undefined || key === '' ) { return; }
	if ( value === undefined ) { value = ''; }
	// For increased compatibility with AdGuard
	if ( value === 'emptyArr' ) {
		value = '[]';
	} else if ( value === 'emptyObj' ) {
		value = '{}';
	}
	const trustedValues = [
		'',
		'undefined', 'null',
		'false', 'true',
		'on', 'off',
		'yes', 'no',
		'{}', '[]', '""',
		'$remove$',
	];
	const normalized = value.toLowerCase();
	const match = /^("?)(.+)\1$/.exec(normalized);
	const unquoted = match && match[2] || normalized;
	if ( trustedValues.includes(unquoted) === false ) {
		if ( /^\d+$/.test(unquoted) === false ) { return; }
		const n = parseInt(unquoted, 10);
		if ( n > 32767 ) { return; }
	}
	try {
		const storage = self.localStorage;
		if ( value === '$remove$' ) {
			const safe = safeSelf();
			const pattern = safe.patternToRegex(key, undefined, true );
			const toRemove = [];
			for ( let i = 0, n = storage.length; i < n; i++ ) {
				const key = storage.key(i);
				if ( pattern.test(key) ) { toRemove.push(key); }
			}
			for ( const key of toRemove ) {
				storage.removeItem(key);
			}
		} else {
			storage.setItem(key, `${value}`);
		}
	} catch(ex) {
	}
}


trusted-set-local-storage-item.js application/javascript
function(key, value) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	if ( key === undefined || key === '' ) { return; }
	if ( value === undefined ) { value = ''; }
	// For increased compatibility with AdGuard
	if ( value === 'emptyArr' ) {
		value = '[]';
	} else if ( value === 'emptyObj' ) {
		value = '{}';
	}
	const trustedValues = [
		'',
		'undefined', 'null',
		'false', 'true',
		'on', 'off',
		'yes', 'no',
		'{}', '[]', '""',
		'$remove$',
	];
	if ( value === '$now$' ) {
		value = Date.now();
	} else if ( value === '$currentDate$' ) {
		value = `${Date()}`;
	} else if ( value === '$currentISODate$' ) {
		value = (new Date()).toISOString();
	}
	try {
		const storage = self.localStorage;
		if ( value === '$remove$' ) {
			const safe = safeSelf();
			const pattern = safe.patternToRegex(key, undefined, true );
			const toRemove = [];
			for ( let i = 0, n = storage.length; i < n; i++ ) {
				const key = storage.key(i);
				if ( pattern.test(key) ) { toRemove.push(key); }
			}
			for ( const key of toRemove ) {
				storage.removeItem(key);
			}
		} else {
			storage.setItem(key, `${value}`);
		}
	} catch(ex) {
	}
}


set-session-storage-item.js application/javascript
function(key, value) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	if ( key === undefined || key === '' ) { return; }
	if ( value === undefined ) { value = ''; }
	// For increased compatibility with AdGuard
	if ( value === 'emptyArr' ) {
		value = '[]';
	} else if ( value === 'emptyObj' ) {
		value = '{}';
	}
	const trustedValues = [
		'',
		'undefined', 'null',
		'false', 'true',
		'on', 'off',
		'yes', 'no',
		'{}', '[]', '""',
		'$remove$',
	];
	const normalized = value.toLowerCase();
	const match = /^("?)(.+)\1$/.exec(normalized);
	const unquoted = match && match[2] || normalized;
	if ( trustedValues.includes(unquoted) === false ) {
		if ( /^\d+$/.test(unquoted) === false ) { return; }
		const n = parseInt(unquoted, 10);
		if ( n > 32767 ) { return; }
	}
	try {
		const storage = self.sessionStorage;
		if ( value === '$remove$' ) {
			const safe = safeSelf();
			const pattern = safe.patternToRegex(key, undefined, true );
			const toRemove = [];
			for ( let i = 0, n = storage.length; i < n; i++ ) {
				const key = storage.key(i);
				if ( pattern.test(key) ) { toRemove.push(key); }
			}
			for ( const key of toRemove ) {
				storage.removeItem(key);
			}
		} else {
			storage.setItem(key, `${value}`);
		}
	} catch(ex) {
	}
}


trusted-set-session-storage-item.js application/javascript
function(key, value) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	if ( key === undefined || key === '' ) { return; }
	if ( value === undefined ) { value = ''; }
	// For increased compatibility with AdGuard
	if ( value === 'emptyArr' ) {
		value = '[]';
	} else if ( value === 'emptyObj' ) {
		value = '{}';
	}
	const trustedValues = [
		'',
		'undefined', 'null',
		'false', 'true',
		'on', 'off',
		'yes', 'no',
		'{}', '[]', '""',
		'$remove$',
	];
	if ( value === '$now$' ) {
		value = Date.now();
	} else if ( value === '$currentDate$' ) {
		value = `${Date()}`;
	} else if ( value === '$currentISODate$' ) {
		value = (new Date()).toISOString();
	}
	try {
		const storage = self.sessionStorage;
		if ( value === '$remove$' ) {
			const safe = safeSelf();
			const pattern = safe.patternToRegex(key, undefined, true );
			const toRemove = [];
			for ( let i = 0, n = storage.length; i < n; i++ ) {
				const key = storage.key(i);
				if ( pattern.test(key) ) { toRemove.push(key); }
			}
			for ( const key of toRemove ) {
				storage.removeItem(key);
			}
		} else {
			storage.setItem(key, `${value}`);
		}
	} catch(ex) {
	}
}


remove-cache-storage-item.js application/javascript
function(cacheNamePattern, requestPattern) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Object_fromEntries': Object.fromEntries.bind(Object),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	if ( cacheNamePattern  === undefined || cacheNamePattern  === '' ) { return; }
	if ( requestPattern === undefined ) { requestPattern = ''; }
	const safe = safeSelf();
	const log = console.log.bind(console, makeLogPrefix('remove-cache-storage-item', cacheNamePattern, requestPattern));
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 2);
	const cacheStorage = self.caches;
	if ( cacheStorage instanceof Object === false ) { return; }
	const reCache = safe.patternToRegex(cacheNamePattern, undefined, true);
	const reRequest = safe.patternToRegex(requestPattern, undefined, true);
	cacheStorage.keys().then(cacheNames => {
		for ( const cacheName of cacheNames ) {
			if ( reCache.test(cacheName) === false ) { continue; }
			if ( requestPattern === '' ) {
				cacheStorage.delete(cacheName).then(result => {
					if ( extraArgs.scriptletLogLevel > 1 ) {
						log(`Deleting ${cacheName}`);
					}
					if ( result !== true ) { return; }
					log(`Deleted ${cacheName}: ${result}`);
				});
				continue;
			}
			cacheStorage.open(cacheName).then(cache => {
				cache.keys().then(requests => {
					for ( const request of requests ) {
						if ( reRequest.test(request.url) === false ) { continue; }
						if ( extraArgs.scriptletLogLevel > 1 ) {
							log(`Deleting ${cacheName}/${request.url}`);
						}
						cache.delete(request).then(result => {
							if ( result !== true ) { return; }
							log(`Deleted ${cacheName}/${request.url}: ${result}`);
						});
					}
				});
			});
		}
	});
}


# Imported from:
# https://github.com/NanoAdblocker/NanoFilters/blob/1f3be7211bb0809c5106996f52564bf10c4525f7/NanoFiltersSource/NanoResources.txt#L82
#
# Speed up or down setTimeout, 3 optional arguments.
# funcMatcher
#      The payload matcher, a string literal or a JavaScript RegExp, defaults
#      to match all.
# delayMatcher
#      The delay matcher, an integer, defaults to 1000.
#      Use `*` to match any delay.
# boostRatio - The delay multiplier when there is a match, 0.5 speeds up by
#      2 times and 2 slows down by 2 times, defaults to 0.05 or speed up
#      20 times. Speed up and down both cap at 50 times.
adjust-setTimeout.js application/javascript
alias nano-setTimeout-booster.js
alias nano-stb.js
function(needleArg, delayArg, boostArg) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	if ( needleArg === undefined ) { needleArg = ''; }
	if ( delayArg === undefined ) { delayArg = ''; }
	if ( boostArg === undefined ) { boostArg = ''; }
	const safe = safeSelf();
	const reNeedle = safe.patternToRegex(needleArg);
	let delay = delayArg !== '*' ? parseInt(delayArg, 10) : -1;
	if ( isNaN(delay) || isFinite(delay) === false ) { delay = 1000; }
	let boost = parseFloat(boostArg);
	boost = isNaN(boost) === false && isFinite(boost)
		? Math.min(Math.max(boost, 0.001), 50)
		: 0.05;
	self.setTimeout = new Proxy(self.setTimeout, {
		apply: function(target, thisArg, args) {
			const [ a, b ] = args;
			if (
				(delay === -1 || b === delay) &&
				reNeedle.test(a.toString())
			) {
				args[1] = b * boost;
			}
			return target.apply(thisArg, args);
		}
	});
}


# Imported from:
# https://github.com/NanoAdblocker/NanoFilters/blob/1f3be7211bb0809c5106996f52564bf10c4525f7/NanoFiltersSource/NanoResources.txt#L126
#
# Speed up or down setInterval, 3 optional arguments.
#      The payload matcher, a string literal or a JavaScript RegExp, defaults
#      to match all.
# delayMatcher
#      The delay matcher, an integer, defaults to 1000.
#      Use `*` to match any delay.
# boostRatio - The delay multiplier when there is a match, 0.5 speeds up by
#      2 times and 2 slows down by 2 times, defaults to 0.05 or speed up
#      20 times. Speed up and down both cap at 50 times.
adjust-setInterval.js application/javascript
alias nano-setInterval-booster.js
alias nano-sib.js
function(needleArg, delayArg, boostArg) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	if ( needleArg === undefined ) { needleArg = ''; }
	if ( delayArg === undefined ) { delayArg = ''; }
	if ( boostArg === undefined ) { boostArg = ''; }
	const safe = safeSelf();
	const reNeedle = safe.patternToRegex(needleArg);
	let delay = delayArg !== '*' ? parseInt(delayArg, 10) : -1;
	if ( isNaN(delay) || isFinite(delay) === false ) { delay = 1000; }
	let boost = parseFloat(boostArg);
	boost = isNaN(boost) === false && isFinite(boost)
		? Math.min(Math.max(boost, 0.001), 50)
		: 0.05;
	self.setInterval = new Proxy(self.setInterval, {
		apply: function(target, thisArg, args) {
			const [ a, b ] = args;
			if (
				(delay === -1 || b === delay) &&
				reNeedle.test(a.toString())
			) {
				args[1] = b * boost;
			}
			return target.apply(thisArg, args);
		}
	});
}


prevent-fetch.js application/javascript
alias no-fetch-if.js
function(propsToMatch, responseBody) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Math_max': Math.max,
			'Math_min': Math.min,
			'Math_random': Math.random,
			'Object_defineProperty': Object.defineProperty.bind(Object),
			'JSON': self.JSON,
			'JSON_stringifyFn': self.JSON.stringify,
			'JSON_stringify': (...args) => safe.JSON_stringifyFn.call(safe.JSON, ...args),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function generateContentFn(directive) {
		const safe = safeSelf();
		const randomize = len => {
			const chunks = [];
			let textSize = 0;
			do {
				const s = safe.Math_random().toString(36).slice(2);
				chunks.push(s);
				textSize += s.length;
			}
			while ( textSize < len );
			return chunks.join(' ').slice(0, len);
		};
		if ( directive === 'true' ) {
			return Promise.resolve(randomize(10));
		}
		if ( directive === 'emptyObj' ) {
			return Promise.resolve('{}');
		}
		if ( directive === 'emptyArr' ) {
			return Promise.resolve('[]');
		}
		if ( directive === 'emptyStr' ) {
			return Promise.resolve('');
		}
		if ( directive.startsWith('length:') ) {
			const match = /^length:(\d+)(?:-(\d+))?$/.exec(directive);
			if ( match ) {
				const min = parseInt(match[1], 10);
				const extent = safe.Math_max(parseInt(match[2], 10) || 0, min) - min;
				const len = safe.Math_min(min + extent * safe.Math_random(), 500000);
				return Promise.resolve(randomize(len | 0));
			}
		}
		return Promise.resolve('');
	}
	if ( propsToMatch === undefined ) { propsToMatch = ''; }
	if ( responseBody === undefined ) { responseBody = ''; }
	const safe = safeSelf();
	const logPrefix = makeLogPrefix('prevent-fetch', propsToMatch, responseBody);
	const log = console.log.bind(console, logPrefix);
	const logErr = console.error.bind(console, logPrefix);
	const needles = [];
	for ( const condition of propsToMatch.split(/\s+/) ) {
		if ( condition === '' ) { continue; }
		const pos = condition.indexOf(':');
		let key, value;
		if ( pos !== -1 ) {
			key = condition.slice(0, pos);
			value = condition.slice(pos + 1);
		} else {
			key = 'url';
			value = condition;
		}
		needles.push({ key, re: safe.patternToRegex(value) });
	}
	self.fetch = new Proxy(self.fetch, {
		apply: function(target, thisArg, args) {
			const details = args[0] instanceof self.Request
				? args[0]
				: Object.assign({ url: args[0] }, args[1]);
			let proceed = true;
			try {
				const props = new Map();
				for ( const prop in details ) {
					let v = details[prop];
					if ( typeof v !== 'string' ) {
						try { v = safe.JSON_stringify(v); }
						catch(ex) { }
					}
					if ( typeof v !== 'string' ) { continue; }
					props.set(prop, v);
				}
				if ( propsToMatch === '' && responseBody === '' ) {
					const out = Array.from(props).map(a => `${a[0]}:${a[1]}`);
					log(`Called: ${out.join('\n')}`);
					return Reflect.apply(target, thisArg, args);
				}
				proceed = needles.length === 0;
				for ( const { key, re } of needles ) {
					if (
						props.has(key) === false ||
						re.test(props.get(key)) === false
					) {
						proceed = true;
						break;
					}
				}
			} catch(ex) {
			}
			if ( proceed ) {
				return Reflect.apply(target, thisArg, args);
			}
			let responseType = '';
			if ( details.mode === undefined || details.mode === 'cors' ) {
				try {
					const desURL = new URL(details.url);
					responseType = desURL.origin !== document.location.origin
						? 'cors'
						: 'basic';
				} catch(ex) {
					logErr(`Error: ${ex}`);
				}
			}
			return generateContentFn(responseBody).then(text => {
				log(`Prevented with response "${text}"`);
				const response = new Response(text, {
					statusText: 'OK',
					headers: {
						'Content-Length': text.length,
					}
				});
				safe.Object_defineProperty(response, 'url', {
					value: details.url
				});
				if ( responseType !== '' ) {
					safe.Object_defineProperty(response, 'type', {
						value: responseType
					});
				}
				return response;
			});
		}
	});
}


no-xhr-if.js application/javascript
alias prevent-xhr.js
function(propsToMatch, directive) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Math_max': Math.max,
			'Math_min': Math.min,
			'Math_random': Math.random,
			'Array_from': Array.from,
			'RegExp': self.RegExp,
			'RegExp_test': self.RegExp.prototype.test,
			'JSON': self.JSON,
			'JSON_stringifyFn': self.JSON.stringify,
			'JSON_stringify': (...args) => safe.JSON_stringifyFn.call(safe.JSON, ...args),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			initPattern(pattern, options = {}) {
				if ( pattern === '' ) {
					return { matchAll: true };
				}
				const expect = (options.canNegate !== true || pattern.startsWith('!') === false);
				if ( expect === false ) {
					pattern = pattern.slice(1);
				}
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match !== null ) {
					return {
						re: new this.RegExp(
							match[1],
							match[2] || options.flags
						),
						expect,
					};
				}
				if ( options.flags !== undefined ) {
					return {
						re: new this.RegExp(this.escapeRegexChars(pattern),
							options.flags
						),
						expect,
					};
				}
				return { pattern, expect };
			},
			testPattern(details, haystack) {
				if ( details.matchAll ) { return true; }
				if ( details.re ) {
					return this.RegExp_test.call(details.re, haystack) === details.expect;
				}
				return haystack.includes(details.pattern) === details.expect;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function parsePropertiesToMatch(propsToMatch, implicit = '') {
		const safe = safeSelf();
		const needles = new Map();
		if ( propsToMatch === undefined || propsToMatch === '' ) { return needles; }
		const options = { canNegate: true };
		for ( const needle of propsToMatch.split(/\s+/) ) {
			const [ prop, pattern ] = needle.split(':');
			if ( prop === '' ) { continue; }
			if ( pattern !== undefined ) {
				needles.set(prop, safe.initPattern(pattern, options));
			} else if ( implicit !== '' ) {
				needles.set(implicit, safe.initPattern(prop, options));
			}
		}
		return needles;
	}
	function matchObjectProperties(propNeedles, ...objs) {
		if ( matchObjectProperties.extractProperties === undefined ) {
			matchObjectProperties.extractProperties = (src, des, props) => {
				for ( const p of props ) {
					const v = src[p];
					if ( v === undefined ) { continue; }
					des[p] = src[p];
				}
			};
		}
		const safe = safeSelf();
		const haystack = {};
		const props = safe.Array_from(propNeedles.keys());
		for ( const obj of objs ) {
			if ( obj instanceof Object === false ) { continue; }
			matchObjectProperties.extractProperties(obj, haystack, props);
		}
		for ( const [ prop, details ] of propNeedles ) {
			let value = haystack[prop];
			if ( value === undefined ) { continue; }
			if ( typeof value !== 'string' ) {
				try { value = safe.JSON_stringify(value); }
				catch(ex) { }
				if ( typeof value !== 'string' ) { continue; }
			}
			if ( safe.testPattern(details, value) ) { continue; }
			return false;
		}
		return true;
	}
	function generateContentFn(directive) {
		const safe = safeSelf();
		const randomize = len => {
			const chunks = [];
			let textSize = 0;
			do {
				const s = safe.Math_random().toString(36).slice(2);
				chunks.push(s);
				textSize += s.length;
			}
			while ( textSize < len );
			return chunks.join(' ').slice(0, len);
		};
		if ( directive === 'true' ) {
			return Promise.resolve(randomize(10));
		}
		if ( directive === 'emptyObj' ) {
			return Promise.resolve('{}');
		}
		if ( directive === 'emptyArr' ) {
			return Promise.resolve('[]');
		}
		if ( directive === 'emptyStr' ) {
			return Promise.resolve('');
		}
		if ( directive.startsWith('length:') ) {
			const match = /^length:(\d+)(?:-(\d+))?$/.exec(directive);
			if ( match ) {
				const min = parseInt(match[1], 10);
				const extent = safe.Math_max(parseInt(match[2], 10) || 0, min) - min;
				const len = safe.Math_min(min + extent * safe.Math_random(), 500000);
				return Promise.resolve(randomize(len | 0));
			}
		}
		return Promise.resolve('');
	}
	if ( propsToMatch === undefined ) { propsToMatch = ''; }
	if ( directive === undefined ) { directive = ''; }
	const safe = safeSelf();
	const log = console.log.bind(console, makeLogPrefix('prevent-xhr', propsToMatch, directive));
	const xhrInstances = new WeakMap();
	const propNeedles = parsePropertiesToMatch(propsToMatch, 'url');
	const headers = {
		'date': '',
		'content-type': '',
		'content-length': '',
	};
	self.XMLHttpRequest = class extends self.XMLHttpRequest {
		open(method, url, ...args) {
			xhrInstances.delete(this);
			const haystack = { method, url };
			if ( propsToMatch === '' && directive === '' ) {
				log(`Called: ${safe.JSON_stringify(haystack, null, 2)}`);
				return super.open(method, url, ...args);
			}
			if ( matchObjectProperties(propNeedles, haystack) ) {
				xhrInstances.set(this, haystack);
			}
			haystack.headers = Object.assign({}, headers);
			return super.open(method, url, ...args);
		}
		send(...args) {
			const haystack = xhrInstances.get(this);
			if ( haystack === undefined ) {
				return super.send(...args);
			}
			haystack.headers['date'] = (new Date()).toUTCString();
			let promise = Promise.resolve({
				xhr: this,
				directive,
				props: {
					readyState: { value: 4 },
					response: { value: '' },
					responseText: { value: '' },
					responseXML: { value: null },
					responseURL: { value: haystack.url },
					status: { value: 200 },
					statusText: { value: 'OK' },
				},
			});
			switch ( this.responseType ) {
			case 'arraybuffer':
				promise = promise.then(details => {
					details.props.response.value = new ArrayBuffer(0);
					return details;
				});
				haystack.headers['content-type'] = 'application/octet-stream';
				break;
			case 'blob':
				promise = promise.then(details => {
					details.props.response.value = new Blob([]);
					return details;
				});
				haystack.headers['content-type'] = 'application/octet-stream';
				break;
			case 'document': {
				promise = promise.then(details => {
					const parser = new DOMParser();
					const doc = parser.parseFromString('', 'text/html');
					details.props.response.value = doc;
					details.props.responseXML.value = doc;
					return details;
				});
				haystack.headers['content-type'] = 'text/html';
				break;
			}
			case 'json':
				promise = promise.then(details => {
					details.props.response.value = {};
					details.props.responseText.value = '{}';
					return details;
				});
				haystack.headers['content-type'] = 'application/json';
				break;
			default:
				if ( directive === '' ) { break; }
				promise = promise.then(details => {
					return generateContentFn(details.directive).then(text => {
						details.props.response.value = text;
						details.props.responseText.value = text;
						return details;
					});
				});
				haystack.headers['content-type'] = 'text/plain';
				break;
			}
			promise.then(details => {
				haystack.headers['content-length'] = `${details.props.response.value}`.length;
				Object.defineProperties(details.xhr, details.props);
				details.xhr.dispatchEvent(new Event('readystatechange'));
				details.xhr.dispatchEvent(new Event('load'));
				details.xhr.dispatchEvent(new Event('loadend'));
				log(`Prevented with response:\n${details.xhr.response}`);
			});
		}
		getResponseHeader(headerName) {
			const haystack = xhrInstances.get(this);
			if ( haystack === undefined || this.readyState < this.HEADERS_RECEIVED ) {
				return super.getResponseHeader(headerName);
			}
			const value = haystack.headers[headerName.toLowerCase()];
			if ( value !== undefined && value !== '' ) { return value; }
			return null;
		}
		getAllResponseHeaders() {
			const haystack = xhrInstances.get(this);
			if ( haystack === undefined || this.readyState < this.HEADERS_RECEIVED ) {
				return super.getAllResponseHeaders();
			}
			const out = [];
			for ( const [ name, value ] of Object.entries(haystack.headers) ) {
				if ( !value ) { continue; }
				out.push(`${name}: ${value}`);
			}
			if ( out.length !== 0 ) { out.push(''); }
			return out.join('\r\n');
		}
	};
}


trusted-replace-xhr-response.js application/javascript
function(pattern, replacement, propsToMatch) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Array_from': Array.from,
			'Object_fromEntries': Object.fromEntries.bind(Object),
			'RegExp': self.RegExp,
			'RegExp_test': self.RegExp.prototype.test,
			'JSON': self.JSON,
			'JSON_stringifyFn': self.JSON.stringify,
			'JSON_stringify': (...args) => safe.JSON_stringifyFn.call(safe.JSON, ...args),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			initPattern(pattern, options = {}) {
				if ( pattern === '' ) {
					return { matchAll: true };
				}
				const expect = (options.canNegate !== true || pattern.startsWith('!') === false);
				if ( expect === false ) {
					pattern = pattern.slice(1);
				}
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match !== null ) {
					return {
						re: new this.RegExp(
							match[1],
							match[2] || options.flags
						),
						expect,
					};
				}
				if ( options.flags !== undefined ) {
					return {
						re: new this.RegExp(this.escapeRegexChars(pattern),
							options.flags
						),
						expect,
					};
				}
				return { pattern, expect };
			},
			testPattern(details, haystack) {
				if ( details.matchAll ) { return true; }
				if ( details.re ) {
					return this.RegExp_test.call(details.re, haystack) === details.expect;
				}
				return haystack.includes(details.pattern) === details.expect;
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function parsePropertiesToMatch(propsToMatch, implicit = '') {
		const safe = safeSelf();
		const needles = new Map();
		if ( propsToMatch === undefined || propsToMatch === '' ) { return needles; }
		const options = { canNegate: true };
		for ( const needle of propsToMatch.split(/\s+/) ) {
			const [ prop, pattern ] = needle.split(':');
			if ( prop === '' ) { continue; }
			if ( pattern !== undefined ) {
				needles.set(prop, safe.initPattern(pattern, options));
			} else if ( implicit !== '' ) {
				needles.set(implicit, safe.initPattern(prop, options));
			}
		}
		return needles;
	}
	function matchObjectProperties(propNeedles, ...objs) {
		if ( matchObjectProperties.extractProperties === undefined ) {
			matchObjectProperties.extractProperties = (src, des, props) => {
				for ( const p of props ) {
					const v = src[p];
					if ( v === undefined ) { continue; }
					des[p] = src[p];
				}
			};
		}
		const safe = safeSelf();
		const haystack = {};
		const props = safe.Array_from(propNeedles.keys());
		for ( const obj of objs ) {
			if ( obj instanceof Object === false ) { continue; }
			matchObjectProperties.extractProperties(obj, haystack, props);
		}
		for ( const [ prop, details ] of propNeedles ) {
			let value = haystack[prop];
			if ( value === undefined ) { continue; }
			if ( typeof value !== 'string' ) {
				try { value = safe.JSON_stringify(value); }
				catch(ex) { }
				if ( typeof value !== 'string' ) { continue; }
			}
			if ( safe.testPattern(details, value) ) { continue; }
			return false;
		}
		return true;
	}
	if ( pattern === undefined || pattern === '' ) { return; }
	if ( replacement === undefined ) { replacement = ''; }
	if ( propsToMatch === undefined ) { propsToMatch = ''; }
	const safe = safeSelf();
	const log = console.log.bind(console, makeLogPrefix('trusted-replace-xhr-response', pattern, replacement, propsToMatch));
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 3);
	const xhrInstances = new WeakMap();
	if ( pattern === '*' ) { pattern = '.*'; }
	const rePattern = safe.patternToRegex(pattern);
	const propNeedles = parsePropertiesToMatch(propsToMatch, 'url');
	self.XMLHttpRequest = class extends self.XMLHttpRequest {
		open(method, url, ...args) {
			const outerXhr = this;
			const xhrDetails = { method, url };
			let outcome = 'match';
			if ( propNeedles.size !== 0 ) {
				if ( matchObjectProperties(propNeedles, xhrDetails) === false ) {
					outcome = 'nomatch';
				}
			}
			if ( outcome === 'match' ) {
				if ( extraArgs.scriptletLogLevel > 1 ) {
					log(`Matched "propsToMatch"`);
				}
				xhrInstances.set(outerXhr, xhrDetails);
			}
			return super.open(method, url, ...args);
		}
		get response() {
			const innerResponse = super.response;
			const xhrDetails = xhrInstances.get(this);
			if ( xhrDetails === undefined ) {
				return innerResponse;
			}
			const responseLength = typeof innerResponse === 'string'
				? innerResponse.length
				: undefined;
			if ( xhrDetails.lastResponseLength !== responseLength ) {
				xhrDetails.response = undefined;
				xhrDetails.lastResponseLength = responseLength;
			}
			if ( xhrDetails.response !== undefined ) {
				return xhrDetails.response;
			}
			if ( typeof innerResponse !== 'string' ) {
				return (xhrDetails.response = innerResponse);
			}
			const textBefore = innerResponse;
			const textAfter = textBefore.replace(rePattern, replacement);
			if ( textAfter !== textBefore ) {
				log('Match');
			}
			return (xhrDetails.response = textAfter);
		}
		get responseText() {
			const response = this.response;
			if ( typeof response !== 'string' ) {
				return super.responseText;
			}
			return response;
		}
	};
}


# Replaces response text content of fetch requests if all given parameters
# match.
#
# Reference:
# https://github.com/AdguardTeam/Scriptlets/blob/master/src/scriptlets/trusted-replace-fetch-response.js
trusted-replace-fetch-response.js application/javascript
alias trusted-rpfr.js
function(pattern, replacement, propsToMatch) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Array_from': Array.from,
			'Object_fromEntries': Object.fromEntries.bind(Object),
			'RegExp': self.RegExp,
			'RegExp_test': self.RegExp.prototype.test,
			'Request_clone': self.Request.prototype.clone,
			'JSON': self.JSON,
			'JSON_stringifyFn': self.JSON.stringify,
			'JSON_stringify': (...args) => safe.JSON_stringifyFn.call(safe.JSON, ...args),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			initPattern(pattern, options = {}) {
				if ( pattern === '' ) {
					return { matchAll: true };
				}
				const expect = (options.canNegate !== true || pattern.startsWith('!') === false);
				if ( expect === false ) {
					pattern = pattern.slice(1);
				}
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match !== null ) {
					return {
						re: new this.RegExp(
							match[1],
							match[2] || options.flags
						),
						expect,
					};
				}
				if ( options.flags !== undefined ) {
					return {
						re: new this.RegExp(this.escapeRegexChars(pattern),
							options.flags
						),
						expect,
					};
				}
				return { pattern, expect };
			},
			testPattern(details, haystack) {
				if ( details.matchAll ) { return true; }
				if ( details.re ) {
					return this.RegExp_test.call(details.re, haystack) === details.expect;
				}
				return haystack.includes(details.pattern) === details.expect;
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function parsePropertiesToMatch(propsToMatch, implicit = '') {
		const safe = safeSelf();
		const needles = new Map();
		if ( propsToMatch === undefined || propsToMatch === '' ) { return needles; }
		const options = { canNegate: true };
		for ( const needle of propsToMatch.split(/\s+/) ) {
			const [ prop, pattern ] = needle.split(':');
			if ( prop === '' ) { continue; }
			if ( pattern !== undefined ) {
				needles.set(prop, safe.initPattern(pattern, options));
			} else if ( implicit !== '' ) {
				needles.set(implicit, safe.initPattern(prop, options));
			}
		}
		return needles;
	}
	function matchObjectProperties(propNeedles, ...objs) {
		if ( matchObjectProperties.extractProperties === undefined ) {
			matchObjectProperties.extractProperties = (src, des, props) => {
				for ( const p of props ) {
					const v = src[p];
					if ( v === undefined ) { continue; }
					des[p] = src[p];
				}
			};
		}
		const safe = safeSelf();
		const haystack = {};
		const props = safe.Array_from(propNeedles.keys());
		for ( const obj of objs ) {
			if ( obj instanceof Object === false ) { continue; }
			matchObjectProperties.extractProperties(obj, haystack, props);
		}
		for ( const [ prop, details ] of propNeedles ) {
			let value = haystack[prop];
			if ( value === undefined ) { continue; }
			if ( typeof value !== 'string' ) {
				try { value = safe.JSON_stringify(value); }
				catch(ex) { }
				if ( typeof value !== 'string' ) { continue; }
			}
			if ( safe.testPattern(details, value) ) { continue; }
			return false;
		}
		return true;
	}
	if ( pattern === undefined || pattern === '' ) { return; }
	if ( replacement === undefined ) { replacement = ''; }
	if ( propsToMatch === undefined ) { propsToMatch = ''; }
	const safe = safeSelf();
	const logPrefix = makeLogPrefix('trusted-replace-fetch-response', pattern, replacement, propsToMatch);
	const log = console.log.bind(console, logPrefix);
	const logErr = console.error.bind(console, logPrefix);
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 3);
	if ( pattern === '*' ) { pattern = '.*'; }
	const rePattern = safe.patternToRegex(pattern);
	const propNeedles = parsePropertiesToMatch(propsToMatch, 'url');
	self.fetch = new Proxy(self.fetch, {
		apply: function(target, thisArg, args) {
			const fetchPromise = Reflect.apply(target, thisArg, args);
			let outcome = 'match';
			if ( propNeedles.size !== 0 ) {
				const objs = [ args[0] instanceof Object ? args[0] : { url: args[0] } ];
				if ( objs[0] instanceof Request ) {
					if ( !objs[0].bodyUsed ) {
						objs[0] = safe.Request_clone.call(objs[0]);
					}
				}
				if ( args[1] instanceof Object ) {
					objs.push(args[1]);
				}
				if ( matchObjectProperties(propNeedles, ...objs) === false ) {
					outcome = 'nomatch';
				}
			}
			if ( outcome === 'nomatch' ) { return fetchPromise; }
			if ( extraArgs.scripletLogLevel > 1 ) {
				log(`Matched "propsToMatch"\n${propsToMatch}`);
			}
			return fetchPromise.then(responseBefore => {
				const response = responseBefore.clone();
				return response.text().then(textBefore => {
						const textAfter = textBefore.replace(rePattern, replacement);
						const outcome = textAfter !== textBefore ? 'match' : 'nomatch';
						if ( outcome === 'nomatch' ) { return responseBefore; }
						log('Replaced');
						const responseAfter = new Response(textAfter, {
							status: responseBefore.status,
							statusText: responseBefore.statusText,
							headers: responseBefore.headers,
						});
						Object.defineProperties(responseAfter, {
							ok: { value: responseBefore.ok },
							redirected: { value: responseBefore.redirected },
							type: { value: responseBefore.type },
							url: { value: responseBefore.url },
						});
						return responseAfter;
				}).catch(reason => {
					logErr(reason);
					return responseBefore;
					});
			}).catch(reason => {
				logErr(reason);
				return fetchPromise;
			});
		}
	});
}


# Sets the specified attribute on the specified elements. This scriptlet runs
# once when the page loads then afterward on DOM mutations.
#
# Reference: https://github.com/AdguardTeam/Scriptlets/blob/master/src/scriptlets/set-attr.js
set-attr.js application/javascript
function(selector, attr, value) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'addEventListener': self.EventTarget.prototype.addEventListener,
			'removeEventListener': self.EventTarget.prototype.removeEventListener,
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function runAt(fn, when) {
		const intFromReadyState = state => {
			const targets = {
				'loading': 1,
				'interactive': 2, 'end': 2, '2': 2,
				'complete': 3, 'idle': 3, '3': 3,
			};
			const tokens = Array.isArray(state) ? state : [ state ];
			for ( const token of tokens ) {
				const prop = `${token}`;
				if ( targets.hasOwnProperty(prop) === false ) { continue; }
				return targets[prop];
			}
			return 0;
		};
		const runAt = intFromReadyState(when);
		if ( intFromReadyState(document.readyState) >= runAt ) {
			fn(); return;
		}
		const onStateChange = ( ) => {
			if ( intFromReadyState(document.readyState) < runAt ) { return; }
			fn();
			safe.removeEventListener.apply(document, args);
		};
		const safe = safeSelf();
		const args = [ 'readystatechange', onStateChange, { capture: true } ];
		safe.addEventListener.apply(document, args);
	}
	if ( selector === undefined || selector === '' ) { return; }
	if ( attr === undefined || attr === '' ) { return; }
	if ( value === undefined ) { value === ''; }
	const log = console.log.bind(console, makeLogPrefix('set-attr', attr, value));
	const validValues = [ '', 'false', 'true' ];
	let copyFrom = '';
	if ( validValues.includes(value.toLowerCase()) === false ) {
		if ( /^\d+$/.test(value) ) {
			const n = parseInt(value, 10);
			if ( n >= 32768 ) { return; }
			value = `${n}`;
		} else if ( /^\[.+\]$/.test(value) ) {
			copyFrom = value.slice(1, -1);
		} else {
			return;
		}
	}
	const extractValue = elem => {
		if ( copyFrom !== '' ) {
			return elem.getAttribute(copyFrom) || '';
		}
		return value;
	};
	const applySetAttr = ( ) => {
		const elems = [];
		try {
			elems.push(...document.querySelectorAll(selector));
		}
		catch(ex) {
			return false;
		}
		for ( const elem of elems ) {
			const before = elem.getAttribute(attr);
			const after = extractValue(elem);
			if ( after === before ) { continue; }
			if ( after !== '' && /^on/i.test(attr) ) {
				if ( attr.toLowerCase() in elem ) { continue; }
			}
			elem.setAttribute(attr, after);
			log(`${attr}="${after}"`);
		}
		return true;
	};
	let observer, timer;
	const onDomChanged = mutations => {
		if ( timer !== undefined ) { return; }
		let shouldWork = false;
		for ( const mutation of mutations ) {
			if ( mutation.addedNodes.length === 0 ) { continue; }
			for ( const node of mutation.addedNodes ) {
				if ( node.nodeType !== 1 ) { continue; }
				shouldWork = true;
				break;
			}
			if ( shouldWork ) { break; }
		}
		if ( shouldWork === false ) { return; }
		timer = self.requestAnimationFrame(( ) => {
			timer = undefined;
			applySetAttr();
		});
	};
	const start = ( ) => {
		if ( applySetAttr() === false ) { return; }
		observer = new MutationObserver(onDomChanged);
		observer.observe(document.body, {
			subtree: true,
			childList: true,
		});
	};
	runAt(( ) => { start(); }, 'idle');
}


remove-attr.js application/javascript
alias ra.js
function(token, selector, behavior) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'addEventListener': self.EventTarget.prototype.addEventListener,
			'removeEventListener': self.EventTarget.prototype.removeEventListener,
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function runAt(fn, when) {
		const intFromReadyState = state => {
			const targets = {
				'loading': 1,
				'interactive': 2, 'end': 2, '2': 2,
				'complete': 3, 'idle': 3, '3': 3,
			};
			const tokens = Array.isArray(state) ? state : [ state ];
			for ( const token of tokens ) {
				const prop = `${token}`;
				if ( targets.hasOwnProperty(prop) === false ) { continue; }
				return targets[prop];
			}
			return 0;
		};
		const runAt = intFromReadyState(when);
		if ( intFromReadyState(document.readyState) >= runAt ) {
			fn(); return;
		}
		const onStateChange = ( ) => {
			if ( intFromReadyState(document.readyState) < runAt ) { return; }
			fn();
			safe.removeEventListener.apply(document, args);
		};
		const safe = safeSelf();
		const args = [ 'readystatechange', onStateChange, { capture: true } ];
		safe.addEventListener.apply(document, args);
	}
	if ( token === undefined || token === '' ) { return; }
	if ( selector === undefined ) { selector = ''; }
	if ( behavior === undefined ) { behavior = ''; }
	const tokens = token.split(/\s*\|\s*/);
	if ( selector === '' ) {
		selector = `[${tokens.join('],[')}]`;
	}
	let timer;
	const rmattr = ( ) => {
		timer = undefined;
		try {
			const nodes = document.querySelectorAll(selector);
			for ( const node of nodes ) {
				for ( const attr of tokens ) {
					node.removeAttribute(attr);
				}
			}
		} catch(ex) {
		}
	};
	const mutationHandler = mutations => {
		if ( timer !== undefined ) { return; }
		let skip = true;
		for ( let i = 0; i < mutations.length && skip; i++ ) {
			const { type, addedNodes, removedNodes } = mutations[i];
			if ( type === 'attributes' ) { skip = false; }
			for ( let j = 0; j < addedNodes.length && skip; j++ ) {
				if ( addedNodes[j].nodeType === 1 ) { skip = false; break; }
			}
			for ( let j = 0; j < removedNodes.length && skip; j++ ) {
				if ( removedNodes[j].nodeType === 1 ) { skip = false; break; }
			}
		}
		if ( skip ) { return; }
		timer = self.requestIdleCallback(rmattr, { timeout: 17 });
	};
	const start = ( ) => {
		rmattr();
		if ( /\bstay\b/.test(behavior) === false ) { return; }
		const observer = new MutationObserver(mutationHandler);
		observer.observe(document, {
			attributes: true,
			attributeFilter: tokens,
			childList: true,
			subtree: true,
		});
	};
	runAt(( ) => {
		start();
	}, /\bcomplete\b/.test(behavior) ? 'idle' : 'interactive');
}


remove-class.js application/javascript
alias rc.js
function(token, selector, behavior) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'addEventListener': self.EventTarget.prototype.addEventListener,
			'removeEventListener': self.EventTarget.prototype.removeEventListener,
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function runAt(fn, when) {
		const intFromReadyState = state => {
			const targets = {
				'loading': 1,
				'interactive': 2, 'end': 2, '2': 2,
				'complete': 3, 'idle': 3, '3': 3,
			};
			const tokens = Array.isArray(state) ? state : [ state ];
			for ( const token of tokens ) {
				const prop = `${token}`;
				if ( targets.hasOwnProperty(prop) === false ) { continue; }
				return targets[prop];
			}
			return 0;
		};
		const runAt = intFromReadyState(when);
		if ( intFromReadyState(document.readyState) >= runAt ) {
			fn(); return;
		}
		const onStateChange = ( ) => {
			if ( intFromReadyState(document.readyState) < runAt ) { return; }
			fn();
			safe.removeEventListener.apply(document, args);
		};
		const safe = safeSelf();
		const args = [ 'readystatechange', onStateChange, { capture: true } ];
		safe.addEventListener.apply(document, args);
	}
	if ( token === undefined || token === '' ) { return; }
	if ( selector === undefined ) { selector = ''; }
	if ( behavior === undefined ) { behavior = ''; }
	const classTokens = token.split(/\s*\|\s*/);
	if ( selector === '' ) {
		selector = '.' + classTokens.map(a => CSS.escape(a)).join(',.');
	}
	const mustStay = /\bstay\b/.test(behavior);
	let timer;
	const rmclass = function() {
		timer = undefined;
		try {
			const nodes = document.querySelectorAll(selector);
			for ( const node of nodes ) {
				node.classList.remove(...classTokens);
			}
		} catch(ex) {
		}
		if ( mustStay ) { return; }
		if ( document.readyState !== 'complete' ) { return; }
		observer.disconnect();
	};
	const mutationHandler = mutations => {
		if ( timer !== undefined ) { return; }
		let skip = true;
		for ( let i = 0; i < mutations.length && skip; i++ ) {
			const { type, addedNodes, removedNodes } = mutations[i];
			if ( type === 'attributes' ) { skip = false; }
			for ( let j = 0; j < addedNodes.length && skip; j++ ) {
				if ( addedNodes[j].nodeType === 1 ) { skip = false; break; }
			}
			for ( let j = 0; j < removedNodes.length && skip; j++ ) {
				if ( removedNodes[j].nodeType === 1 ) { skip = false; break; }
			}
		}
		if ( skip ) { return; }
		timer = self.requestIdleCallback(rmclass, { timeout: 67 });
	};
	const observer = new MutationObserver(mutationHandler);
	const start = ( ) => {
		rmclass();
		observer.observe(document, {
			attributes: true,
			attributeFilter: [ 'class' ],
			childList: true,
			subtree: true,
		});
	};
	runAt(( ) => {
		start();
	}, /\bcomplete\b/.test(behavior) ? 'idle' : 'loading');
}


spoof-css.js application/javascript
function(selector) {
	'use strict';
	if ( selector === undefined || selector === '' ) { return; }
	const extraArgs = Array.from(arguments).slice(1);
	const toCamelCase = s => s.replace(/-[a-z]/g, s => s.charAt(1).toUpperCase());
	const propToValueMap = new Map();
	for ( let i = 0; i < extraArgs.length; i += 2 ) {
		if ( typeof extraArgs[i+0] !== 'string' ) { break; }
		if ( extraArgs[i+0] === '' ) { break; }
		if ( typeof extraArgs[i+1] !== 'string' ) { break; }
		propToValueMap.set(toCamelCase(extraArgs[i+0]), extraArgs[i+1]);
	}
	const log = console.log.bind(console, makeLogPrefix('spoof-css', selector, ...extraArgs));
	const shouldDebug = propToValueMap.get('debug') || 0;
	const instanceProperties = [ 'cssText', 'length', 'parentRule' ];
	const spoofStyle = (prop, real) => {
		const normalProp = toCamelCase(prop);
		const shouldSpoof = propToValueMap.has(normalProp);
		const value = shouldSpoof ? propToValueMap.get(normalProp) : real;
		if ( shouldSpoof ) {
			log(`Spoofing ${prop} to ${value}`);
		}
		return value;
	};
	const cloackFunc = (fn, thisArg, name) => {
		const trap = fn.bind(thisArg);
		Object.defineProperty(trap, 'name', { value: name });
		Object.defineProperty(trap, 'toString', {
			value: ( ) => `function ${name}() { [native code] }`
		});
		return trap;
	};
	self.getComputedStyle = new Proxy(self.getComputedStyle, {
		apply: function(target, thisArg, args) {
			if ( shouldDebug !== 0 ) { debugger; }	// jshint ignore: line
			const style = Reflect.apply(target, thisArg, args);
			const targetElements = new WeakSet(document.querySelectorAll(selector));
			if ( targetElements.has(args[0]) === false ) { return style; }
			const proxiedStyle = new Proxy(style, {
				get(target, prop, receiver) {
					if ( typeof target[prop] === 'function' ) {
						if ( prop === 'getPropertyValue' ) {
							return cloackFunc(function getPropertyValue(prop) {
								return spoofStyle(prop, target[prop]);
							}, target, 'getPropertyValue');
						}
						return cloackFunc(target[prop], target, prop);
					}
					if ( instanceProperties.includes(prop) ) {
						return Reflect.get(target, prop);
					}
					return spoofStyle(prop, Reflect.get(target, prop, receiver));
				},
				getOwnPropertyDescriptor(target, prop) {
					if ( propToValueMap.has(prop) ) {
						return {
							configurable: true,
							enumerable: true,
							value: propToValueMap.get(prop),
							writable: true,
						};
					}
					return Reflect.getOwnPropertyDescriptor(target, prop);
				},
			});
			return proxiedStyle;
		},
		get(target, prop, receiver) {
			if ( prop === 'toString' ) {
				return target.toString.bind(target);
			}
			return Reflect.get(target, prop, receiver);
		},
	});
	Element.prototype.getBoundingClientRect = new Proxy(Element.prototype.getBoundingClientRect, {
		apply: function(target, thisArg, args) {
			if ( shouldDebug !== 0 ) { debugger; }	// jshint ignore: line
			const rect = Reflect.apply(target, thisArg, args);
			const targetElements = new WeakSet(document.querySelectorAll(selector));
			if ( targetElements.has(thisArg) === false ) { return rect; }
			let { height, width } = rect;
			if ( propToValueMap.has('width') ) {
				width = parseFloat(propToValueMap.get('width'));
			}
			if ( propToValueMap.has('height') ) {
				height = parseFloat(propToValueMap.get('height'));
			}
			return new DOMRect(rect.x, rect.y, width, height);
		},
		get(target, prop, receiver) {
			if ( prop === 'toString' ) {
				return target.toString.bind(target);
			}
			return Reflect.get(target, prop, receiver);
		},
	});
}


# Set the `href` attribute to a value found in the DOM at, or below the
# targeted `a` element.
href-sanitizer.js application/javascript
function(selector, source) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'addEventListener': self.EventTarget.prototype.addEventListener,
			'removeEventListener': self.EventTarget.prototype.removeEventListener,
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function runAt(fn, when) {
		const intFromReadyState = state => {
			const targets = {
				'loading': 1,
				'interactive': 2, 'end': 2, '2': 2,
				'complete': 3, 'idle': 3, '3': 3,
			};
			const tokens = Array.isArray(state) ? state : [ state ];
			for ( const token of tokens ) {
				const prop = `${token}`;
				if ( targets.hasOwnProperty(prop) === false ) { continue; }
				return targets[prop];
			}
			return 0;
		};
		const runAt = intFromReadyState(when);
		if ( intFromReadyState(document.readyState) >= runAt ) {
			fn(); return;
		}
		const onStateChange = ( ) => {
			if ( intFromReadyState(document.readyState) < runAt ) { return; }
			fn();
			safe.removeEventListener.apply(document, args);
		};
		const safe = safeSelf();
		const args = [ 'readystatechange', onStateChange, { capture: true } ];
		safe.addEventListener.apply(document, args);
	}
	if ( selector === undefined || selector === '' ) { return; }
	if ( source === undefined || source === '' ) { source = 'text'; }
	const log = console.log.bind(console, makeLogPrefix('href-sanitizer', selector, source));
	const sanitizeCopycats = (href, text) => {
		let elems = [];
		try {
			elems = document.querySelectorAll(`a[href="${href}"`);
		}
		catch(ex) {
		}
		for ( const elem of elems ) {
			elem.setAttribute('href', text);
		}
		return elems.length;
	};
	const validateURL = text => {
		if ( text === '' ) { return ''; }
		if ( /[^\x21-\x7e]/.test(text) ) { return ''; }
		try {
			const url = new URL(text, document.location);
			return url.href;
		} catch(ex) {
		}
		return '';
	};
	const extractText = (elem, source) => {
		if ( /^\[.*\]$/.test(source) ) {
			return elem.getAttribute(source.slice(1,-1).trim()) || '';
		}
		if ( source.startsWith('?') ) {
			try {
				const url = new URL(elem.href, document.location);
				return url.searchParams.get(source.slice(1)) || '';
			} catch(x) {
			}
			return '';
		}
		if ( source === 'text' ) {
			return elem.textContent
				.replace(/^[^\x21-\x7e]+/, '') // remove leading invalid characters
				.replace(/[^\x21-\x7e]+$/, '') // remove trailing invalid characters
			;
		}
		return '';
	};
	const sanitize = ( ) => {
		let elems = [];
		try {
			elems = document.querySelectorAll(selector);
		}
		catch(ex) {
			return false;
		}
		for ( const elem of elems ) {
			if ( elem.localName !== 'a' ) { continue; }
			if ( elem.hasAttribute('href') === false ) { continue; }
			const href = elem.getAttribute('href');
			const text = extractText(elem, source);
			const hrefAfter = validateURL(text);
			if ( hrefAfter === '' ) { continue; }
			if ( hrefAfter === href ) { continue; }
			elem.setAttribute('href', hrefAfter);
			const count = sanitizeCopycats(href, hrefAfter);
			log(`Sanitized ${count+1} links to\n${hrefAfter}`);
		}
		return true;
	};
	let observer, timer;
	const onDomChanged = mutations => {
		if ( timer !== undefined ) { return; }
		let shouldSanitize = false;
		for ( const mutation of mutations ) {
			if ( mutation.addedNodes.length === 0 ) { continue; }
			for ( const node of mutation.addedNodes ) {
				if ( node.nodeType !== 1 ) { continue; }
				shouldSanitize = true;
				break;
			}
			if ( shouldSanitize ) { break; }
		}
		if ( shouldSanitize === false ) { return; }
		timer = self.requestIdleCallback(( ) => {
			timer = undefined;
			sanitize();
		});
	};
	const start = ( ) => {
		if ( sanitize() === false ) { return; }
		observer = new MutationObserver(onDomChanged);
		observer.observe(document.body, {
			subtree: true,
			childList: true,
		});
	};
	runAt(( ) => { start(); }, 'interactive');
}


# Replace text instance(s) with another text instance inside specific
# DOM nodes. By default, the scriplet stops and quits at the interactive
# stage of a document.
#
# See commit messages for usage:
# - https://github.com/gorhill/uBlock/commit/99ce027fd702
# - https://github.com/gorhill/uBlock/commit/41876336db48
trusted-replace-node-text.js application/javascript
alias trusted-rpnt.js
alias replace-node-text.js
alias rpnt.js
function(nodeName, pattern, replacement) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Object_fromEntries': Object.fromEntries.bind(Object),
			'RegExp_test': self.RegExp.prototype.test,
			'addEventListener': self.EventTarget.prototype.addEventListener,
			'removeEventListener': self.EventTarget.prototype.removeEventListener,
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function runAt(fn, when) {
		const intFromReadyState = state => {
			const targets = {
				'loading': 1,
				'interactive': 2, 'end': 2, '2': 2,
				'complete': 3, 'idle': 3, '3': 3,
			};
			const tokens = Array.isArray(state) ? state : [ state ];
			for ( const token of tokens ) {
				const prop = `${token}`;
				if ( targets.hasOwnProperty(prop) === false ) { continue; }
				return targets[prop];
			}
			return 0;
		};
		const runAt = intFromReadyState(when);
		if ( intFromReadyState(document.readyState) >= runAt ) {
			fn(); return;
		}
		const onStateChange = ( ) => {
			if ( intFromReadyState(document.readyState) < runAt ) { return; }
			fn();
			safe.removeEventListener.apply(document, args);
		};
		const safe = safeSelf();
		const args = [ 'readystatechange', onStateChange, { capture: true } ];
		safe.addEventListener.apply(document, args);
	}
	function replaceNodeTextFn(
		nodeName = '',
		pattern = '',
		replacement = ''
	) {
		const safe = safeSelf();
		const log = console.log.bind(console, makeLogPrefix('trusted-replace-node-text', ...arguments));
		const reNodeName = safe.patternToRegex(nodeName, 'i', true);
		const rePattern = safe.patternToRegex(pattern, 'gms');
		const extraArgs = safe.getExtraArgs(Array.from(arguments), 3);
		const reCondition = safe.patternToRegex(extraArgs.condition || '', 'ms');
		const stop = (takeRecord = true) => {
			if ( takeRecord ) {
				handleMutations(observer.takeRecords());
			}
			observer.disconnect();
			if ( extraArgs.scriptletLogLevel > 1 ) {
				log('Quitting');
			}
		};
		let sedCount = extraArgs.sedCount || 0;
		const handleNode = node => {
			const before = node.textContent;
			reCondition.lastIndex = 0;
			if ( safe.RegExp_test.call(reCondition, before) === false ) { return true; }
			rePattern.lastIndex = 0;
			if ( safe.RegExp_test.call(rePattern, before) === false ) { return true; }
			rePattern.lastIndex = 0;
			const after = pattern !== ''
				? before.replace(rePattern, replacement)
				: replacement;
			node.textContent = after;
			if ( extraArgs.scriptletLogLevel > 1 ) {
				log(`Text before:\n${before.trim()}`);
			}
			log(`Text after:\n${after.trim()}`);
			return sedCount === 0 || (sedCount -= 1) !== 0;
		};
		const handleMutations = mutations => {
			for ( const mutation of mutations ) {
				for ( const node of mutation.addedNodes ) {
					if ( reNodeName.test(node.nodeName) === false ) { continue; }
					if ( handleNode(node) ) { continue; }
					stop(false); return;
				}
			}
		};
		const observer = new MutationObserver(handleMutations);
		observer.observe(document, { childList: true, subtree: true });
		if ( document.documentElement ) {
			const treeWalker = document.createTreeWalker(
				document.documentElement,
				NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT
			);
			let count = 0;
			for (;;) {
				const node = treeWalker.nextNode();
				count += 1;
				if ( node === null ) { break; }
				if ( reNodeName.test(node.nodeName) === false ) { continue; }
				if ( handleNode(node) ) { continue; }
				stop(); break;
			}
			log(`${count} nodes present before installing mutation observer`);
		}
		if ( extraArgs.stay ) { return; }
		runAt(( ) => {
			const quitAfter = extraArgs.quitAfter || 0;
			if ( quitAfter !== 0 ) {
				setTimeout(( ) => { stop(); }, quitAfter);
			} else {
				stop();
			}
		}, 'interactive');
	}
	if ( arguments.length > 3 ) {
		const extraArgs = Array.from(arguments).slice(3);
		replaceNodeTextFn(nodeName, pattern, replacement, ...extraArgs);
	} else {
		replaceNodeTextFn(nodeName, pattern, replacement);
	}
}


remove-node-text.js application/javascript
alias rmnt.js
function(nodeName, condition) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Object_fromEntries': Object.fromEntries.bind(Object),
			'RegExp_test': self.RegExp.prototype.test,
			'addEventListener': self.EventTarget.prototype.addEventListener,
			'removeEventListener': self.EventTarget.prototype.removeEventListener,
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function runAt(fn, when) {
		const intFromReadyState = state => {
			const targets = {
				'loading': 1,
				'interactive': 2, 'end': 2, '2': 2,
				'complete': 3, 'idle': 3, '3': 3,
			};
			const tokens = Array.isArray(state) ? state : [ state ];
			for ( const token of tokens ) {
				const prop = `${token}`;
				if ( targets.hasOwnProperty(prop) === false ) { continue; }
				return targets[prop];
			}
			return 0;
		};
		const runAt = intFromReadyState(when);
		if ( intFromReadyState(document.readyState) >= runAt ) {
			fn(); return;
		}
		const onStateChange = ( ) => {
			if ( intFromReadyState(document.readyState) < runAt ) { return; }
			fn();
			safe.removeEventListener.apply(document, args);
		};
		const safe = safeSelf();
		const args = [ 'readystatechange', onStateChange, { capture: true } ];
		safe.addEventListener.apply(document, args);
	}
	function replaceNodeTextFn(
		nodeName = '',
		pattern = '',
		replacement = ''
	) {
		const safe = safeSelf();
		const log = console.log.bind(console, makeLogPrefix('remove-node-text', ...arguments));
		const reNodeName = safe.patternToRegex(nodeName, 'i', true);
		const rePattern = safe.patternToRegex(pattern, 'gms');
		const extraArgs = safe.getExtraArgs(Array.from(arguments), 3);
		const reCondition = safe.patternToRegex(extraArgs.condition || '', 'ms');
		const stop = (takeRecord = true) => {
			if ( takeRecord ) {
				handleMutations(observer.takeRecords());
			}
			observer.disconnect();
			if ( extraArgs.scriptletLogLevel > 1 ) {
				log('Quitting');
			}
		};
		let sedCount = extraArgs.sedCount || 0;
		const handleNode = node => {
			const before = node.textContent;
			reCondition.lastIndex = 0;
			if ( safe.RegExp_test.call(reCondition, before) === false ) { return true; }
			rePattern.lastIndex = 0;
			if ( safe.RegExp_test.call(rePattern, before) === false ) { return true; }
			rePattern.lastIndex = 0;
			const after = pattern !== ''
				? before.replace(rePattern, replacement)
				: replacement;
			node.textContent = after;
			if ( extraArgs.scriptletLogLevel > 1 ) {
				log(`Text before:\n${before.trim()}`);
			}
			log(`Text after:\n${after.trim()}`);
			return sedCount === 0 || (sedCount -= 1) !== 0;
		};
		const handleMutations = mutations => {
			for ( const mutation of mutations ) {
				for ( const node of mutation.addedNodes ) {
					if ( reNodeName.test(node.nodeName) === false ) { continue; }
					if ( handleNode(node) ) { continue; }
					stop(false); return;
				}
			}
		};
		const observer = new MutationObserver(handleMutations);
		observer.observe(document, { childList: true, subtree: true });
		if ( document.documentElement ) {
			const treeWalker = document.createTreeWalker(
				document.documentElement,
				NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT
			);
			let count = 0;
			for (;;) {
				const node = treeWalker.nextNode();
				count += 1;
				if ( node === null ) { break; }
				if ( reNodeName.test(node.nodeName) === false ) { continue; }
				if ( handleNode(node) ) { continue; }
				stop(); break;
			}
			log(`${count} nodes present before installing mutation observer`);
		}
		if ( extraArgs.stay ) { return; }
		runAt(( ) => {
			const quitAfter = extraArgs.quitAfter || 0;
			if ( quitAfter !== 0 ) {
				setTimeout(( ) => { stop(); }, quitAfter);
			} else {
				stop();
			}
		}, 'interactive');
	}
	if ( arguments.length > 2 ) {
		const extraArgs = Array.from(arguments).slice(2);
		replaceNodeTextFn(nodeName, '', '', 'condition', condition, ...extraArgs);
	} else {
		replaceNodeTextFn(nodeName, '', '', 'condition', condition);
	}
}


# Reference API:
# https://github.com/AdguardTeam/Scriptlets/blob/master/src/scriptlets/trusted-click-element.js
trusted-click-element.js application/javascript
function(selectors, extraMatch, delay) {
	'use strict';
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function getAllCookiesFn() {
		return document.cookie.split(/\s*;\s*/).map(s => {
			const pos = s.indexOf('=');
			if ( pos === 0 ) { return; }
			if ( pos === -1 ) { return `${s.trim()}=`; }
			const key = s.slice(0, pos).trim();
			const value = s.slice(pos+1).trim();
			return { key, value };
		}).filter(s => s !== undefined);
	}
	function getAllLocalStorageFn(which = 'localStorage') {
		const storage = self[which];
		const out = [];
		for ( let i = 0; i < storage.length; i++ ) {
			const key = storage.key(i);
			const value = storage.getItem(key);
			return { key, value };
		}
		return out;
	}
	function runAtHtmlElementFn(fn) {
		if ( document.documentElement ) {
			fn();
			return;
		}
		const observer = new MutationObserver(( ) => {
			observer.disconnect();
			fn();
		});
		observer.observe(document, { childList: true });
	}
	if ( selectors === undefined || selectors === '' ) { return; }
	if ( extraMatch === undefined ) { extraMatch = ''; }
	if ( delay === undefined ) { delay = ''; }
	const log = console.log.bind(console, makeLogPrefix('trusted-click-element', selectors, extraMatch, delay));
	if ( extraMatch !== '' ) {
		const assertions = extraMatch.split(',').map(s => {
			const pos1 = s.indexOf(':');
			const s1 = pos1 !== -1 ? s.slice(0, pos1) : s;
			const not = s1.startsWith('!');
			const type = not ? s1.slice(1) : s1;
			const s2 = pos1 !== -1 ? s.slice(pos1+1).trim() : '';
			if ( s2 === '' ) { return; }
			const out = { not, type };
			const match = /^\/(.+)\/(i?)$/.exec(s2);
			if ( match !== null ) {
				out.re = new RegExp(match[1], match[2] || undefined);
				return out;
			}
			const pos2 = s2.indexOf('=');
			const key = pos2 !== -1 ? s2.slice(0, pos2).trim() : s2;
			const value = pos2 !== -1 ? s2.slice(pos2+1).trim() : '';
			out.re = new RegExp(`^${this.escapeRegexChars(key)}=${this.escapeRegexChars(value)}`);
			return out;
		}).filter(details => details !== undefined);
		const allCookies = assertions.some(o => o.type === 'cookie')
			? getAllCookiesFn()
			: [];
		const allStorageItems = assertions.some(o => o.type === 'localStorage')
			? getAllLocalStorageFn()
			: [];
		const hasNeedle = (haystack, needle) => {
			for ( const { key, value } of haystack ) {
				if ( needle.test(`${key}=${value}`) ) { return true; }
			}
			return false;
		};
		for ( const { not, type, re } of assertions ) {
			switch ( type ) {
			case 'cookie':
				if ( hasNeedle(allCookies, re) === not ) { return; }
				break;
			case 'localStorage':
				if ( hasNeedle(allStorageItems, re) === not ) { return; }
				break;
			}
		}
	}
	const querySelectorEx = (selector, context = document) => {
		const pos = selector.indexOf(' >>> ');
		if ( pos === -1 ) { return context.querySelector(selector); }
		const outside = selector.slice(0, pos).trim();
		const inside = selector.slice(pos + 5).trim();
		const elem = context.querySelector(outside);
		if ( elem === null ) { return null; }
		const shadowRoot = elem.shadowRoot;
		return shadowRoot && querySelectorEx(inside, shadowRoot);
	};
	const selectorList = selectors.split(/\s*,\s*/)
		.filter(s => {
			try {
				void querySelectorEx(s);
			} catch(_) {
				return false;
			}
			return true;
		});
	if ( selectorList.length === 0 ) { return; }
	const clickDelay = parseInt(delay, 10) || 1;
	const t0 = Date.now();
	const tbye = t0 + 10000;
	let tnext = selectorList.length !== 1 ? t0 : t0 + clickDelay;
	const terminate = ( ) => {
		selectorList.length = 0;
		next.stop();
		observe.stop();
	};
	const next = notFound => {
		if ( selectorList.length === 0 ) {
			log('Completed');
			return terminate();
		}
		const tnow = Date.now();
		if ( tnow >= tbye ) {
			log('Timed out');
			return terminate();
		}
		if ( notFound ) { observe(); }
		const delay = Math.max(notFound ? tbye - tnow : tnext - tnow, 1);
		next.timer = setTimeout(( ) => {
			next.timer = undefined;
			process();
		}, delay);
		log(`Waiting for ${selectorList[0]}...`);
	};
	next.stop = ( ) => {
		if ( next.timer === undefined ) { return; }
		clearTimeout(next.timer);
		next.timer = undefined;
	};
	const observe = ( ) => {
		if ( observe.observer !== undefined ) { return; }
		observe.observer = new MutationObserver(( ) => {
			if ( observe.timer !== undefined ) { return; }
			observe.timer = setTimeout(( ) => {
				observe.timer = undefined;
				process();
			}, 20);
		});
		observe.observer.observe(document, {
			attributes: true,
			childList: true,
			subtree: true,
		});
	};
	observe.stop = ( ) => {
		if ( observe.timer !== undefined ) {
			clearTimeout(observe.timer);
			observe.timer = undefined;
		}
		if ( observe.observer ) {
			observe.observer.disconnect();
			observe.observer = undefined;
		}
	};
	const process = ( ) => {
		next.stop();
		if ( Date.now() < tnext ) { return next(); }
		const selector = selectorList.shift();
		if ( selector === undefined ) { return terminate(); }
		const elem = querySelectorEx(selector);
		if ( elem === null ) {
			selectorList.unshift(selector);
			return next(true);
		}
		log(`Clicked ${selector}`);
		elem.click();
		tnext += clickDelay;
		next();
	};
	runAtHtmlElementFn(process);
}


trusted-prune-inbound-object.js application/javascript
function(entryPoint, argPos, rawPrunePaths, rawNeedlePaths) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Error': self.Error,
			'Math_floor': Math.floor,
			'Math_random': Math.random,
			'Object_fromEntries': Object.fromEntries.bind(Object),
			'RegExp': self.RegExp,
			'RegExp_test': self.RegExp.prototype.test,
			'RegExp_exec': self.RegExp.prototype.exec,
			'JSON': self.JSON,
			'JSON_parseFn': self.JSON.parse,
			'JSON_stringifyFn': self.JSON.stringify,
			'JSON_parse': (...args) => safe.JSON_parseFn.call(safe.JSON, ...args),
			'JSON_stringify': (...args) => safe.JSON_stringifyFn.call(safe.JSON, ...args),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			initPattern(pattern, options = {}) {
				if ( pattern === '' ) {
					return { matchAll: true };
				}
				const expect = (options.canNegate !== true || pattern.startsWith('!') === false);
				if ( expect === false ) {
					pattern = pattern.slice(1);
				}
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match !== null ) {
					return {
						re: new this.RegExp(
							match[1],
							match[2] || options.flags
						),
						expect,
					};
				}
				if ( options.flags !== undefined ) {
					return {
						re: new this.RegExp(this.escapeRegexChars(pattern),
							options.flags
						),
						expect,
					};
				}
				return { pattern, expect };
			},
			testPattern(details, haystack) {
				if ( details.matchAll ) { return true; }
				if ( details.re ) {
					return this.RegExp_test.call(details.re, haystack) === details.expect;
				}
				return haystack.includes(details.pattern) === details.expect;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function getExceptionToken() {
		const safe = safeSelf();
		const token =
			String.fromCharCode(Date.now() % 26 + 97) +
			safe.Math_floor(safe.Math_random() * 982451653 + 982451653).toString(36);
		const oe = self.onerror;
		self.onerror = function(msg, ...args) {
			if ( typeof msg === 'string' && msg.includes(token) ) { return true; }
			if ( oe instanceof Function ) {
				return oe.call(this, msg, ...args);
			}
		}.bind();
		return token;
	}
	function matchesStackTrace(
		needleDetails,
		logLevel = ''
	) {
		const safe = safeSelf();
		const log = console.log.bind(console);
		const exceptionToken = getExceptionToken();
		const error = new safe.Error(exceptionToken);
		const docURL = new URL(self.location.href);
		docURL.hash = '';
		// Normalize stack trace
		const reLine = /(.*?@)?(\S+)(:\d+):\d+\)?$/;
		const lines = [];
		for ( let line of error.stack.split(/[\n\r]+/) ) {
			if ( line.includes(exceptionToken) ) { continue; }
			line = line.trim();
			const match = safe.RegExp_exec.call(reLine, line);
			if ( match === null ) { continue; }
			let url = match[2];
			if ( url.startsWith('(') ) { url = url.slice(1); }
			if ( url === docURL.href ) {
				url = 'inlineScript';
			} else if ( url.startsWith('<anonymous>') ) {
				url = 'injectedScript';
			}
			let fn = match[1] !== undefined
				? match[1].slice(0, -1)
				: line.slice(0, match.index).trim();
			if ( fn.startsWith('at') ) { fn = fn.slice(2).trim(); }
			let rowcol = match[3];
			lines.push(' ' + `${fn} ${url}${rowcol}:1`.trim());
		}
		lines[0] = `stackDepth:${lines.length-1}`;
		const stack = lines.join('\t');
		const r = needleDetails.matchAll !== true &&
			safe.testPattern(needleDetails, stack);
		if (
			logLevel === 'all' ||
			logLevel === 'match' && r ||
			logLevel === 'nomatch' && !r
		) {
			log(stack.replace(/\t/g, '\n'));
		}
		return r;
	}
	function objectFindOwnerFn(
		root,
		path,
		prune = false
	) {
		let owner = root;
		let chain = path;
		for (;;) {
			if ( typeof owner !== 'object' || owner === null  ) { return false; }
			const pos = chain.indexOf('.');
			if ( pos === -1 ) {
				if ( prune === false ) {
					return owner.hasOwnProperty(chain);
				}
				let modified = false;
				if ( chain === '*' ) {
					for ( const key in owner ) {
						if ( owner.hasOwnProperty(key) === false ) { continue; }
						delete owner[key];
						modified = true;
					}
				} else if ( owner.hasOwnProperty(chain) ) {
					delete owner[chain];
					modified = true;
				}
				return modified;
			}
			const prop = chain.slice(0, pos);
			const next = chain.slice(pos + 1);
			let found = false;
			if ( prop === '[-]' && Array.isArray(owner) ) {
				let i = owner.length;
				while ( i-- ) {
					if ( objectFindOwnerFn(owner[i], next) === false ) { continue; }
					owner.splice(i, 1);
					found = true;
				}
				return found;
			}
			if ( prop === '{-}' && owner instanceof Object ) {
				for ( const key of Object.keys(owner) ) {
					if ( objectFindOwnerFn(owner[key], next) === false ) { continue; }
					delete owner[key];
					found = true;
				}
				return found;
			}
			if (
				prop === '[]' && Array.isArray(owner) ||
				prop === '{}' && owner instanceof Object ||
				prop === '*' && owner instanceof Object
			) {
				for ( const key of Object.keys(owner) ) {
					if (objectFindOwnerFn(owner[key], next, prune) === false ) { continue; }
					found = true;
				}
				return found;
			}
			if ( owner.hasOwnProperty(prop) === false ) { return false; }
			owner = owner[prop];
			chain = chain.slice(pos + 1);
		}
	}
	function objectPruneFn(
		obj,
		rawPrunePaths,
		rawNeedlePaths,
		stackNeedleDetails = { matchAll: true },
		extraArgs = {}
	) {
		if ( typeof rawPrunePaths !== 'string' ) { return; }
		const prunePaths = rawPrunePaths !== ''
			? rawPrunePaths.split(/ +/)
			: [];
		const needlePaths = prunePaths.length !== 0 && rawNeedlePaths !== ''
			? rawNeedlePaths.split(/ +/)
			: [];
		if ( stackNeedleDetails.matchAll !== true ) {
			if ( matchesStackTrace(stackNeedleDetails, extraArgs.logstack) === false ) {
				return;
			}
		}
		if ( objectPruneFn.mustProcess === undefined ) {
			objectPruneFn.mustProcess = (root, needlePaths) => {
				for ( const needlePath of needlePaths ) {
					if ( objectFindOwnerFn(root, needlePath) === false ) {
						return false;
					}
				}
				return true;
			};
		}
		if ( prunePaths.length === 0 ) { return; }
		let outcome = 'nomatch';
		if ( objectPruneFn.mustProcess(obj, needlePaths) ) {
			for ( const path of prunePaths ) {
				if ( objectFindOwnerFn(obj, path, true) ) {
					outcome = 'match';
				}
			}
		}
		if ( outcome === 'match' ) { return obj; }
	}
	if ( entryPoint === undefined || entryPoint === '' ) { return; }
	if ( argPos === undefined || argPos === '' ) { return; }
	if ( rawPrunePaths === undefined ) { rawPrunePaths = ''; }
	if ( rawNeedlePaths === undefined ) { rawNeedlePaths = ''; }
	let context = self;
	let prop = entryPoint;
	for (;;) {
		const pos = prop.indexOf('.');
		if ( pos === -1 ) { break; }
		context = context[prop.slice(0, pos)];
		if ( context instanceof Object === false ) { return; }
		prop = prop.slice(pos+1);
	}
	if ( typeof context[prop] !== 'function' ) { return; }
	const argIndex = parseInt(argPos);
	if ( isNaN(argIndex) ) { return; }
	if ( argIndex < 1 ) { return; }
	const safe = safeSelf();
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 4);
	const needlePaths = [];
	if ( rawPrunePaths !== '' ) {
		needlePaths.push(...rawPrunePaths.split(/ +/));
	}
	if ( rawNeedlePaths !== '' ) {
		needlePaths.push(...rawNeedlePaths.split(/ +/));
	}
	const stackNeedle = safe.initPattern(extraArgs.stackToMatch || '', { canNegate: true });
	const mustProcess = root => {
		for ( const needlePath of needlePaths ) {
			if ( objectFindOwnerFn(root, needlePath) === false ) {
				return false;
			}
		}
		return true;
	};
	context[prop] = new Proxy(context[prop], {
		apply: function(target, thisArg, args) {
			const targetArg = argIndex <= args.length
				? args[argIndex-1]
				: undefined;
			if ( targetArg instanceof Object && mustProcess(targetArg) ) {
				let objBefore = targetArg;
				if ( extraArgs.dontOverwrite ) {
					try {
						objBefore = safe.JSON_parse(safe.JSON_stringify(targetArg));
					} catch(_) {
						objBefore = undefined;
					}
				}
				if ( objBefore !== undefined ) {
					const objAfter = objectPruneFn(
						objBefore,
						rawPrunePaths,
						rawNeedlePaths,
						stackNeedle,
						extraArgs
					);
					args[argIndex-1] = objAfter || objBefore;
				}
			}
			return Reflect.apply(target, thisArg, args);
		},
	});
}


trusted-prune-outbound-object.js application/javascript
function(propChain, rawPrunePaths, rawNeedlePaths) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Error': self.Error,
			'Math_floor': Math.floor,
			'Math_random': Math.random,
			'Object_fromEntries': Object.fromEntries.bind(Object),
			'RegExp_test': self.RegExp.prototype.test,
			'RegExp_exec': self.RegExp.prototype.exec,
			testPattern(details, haystack) {
				if ( details.matchAll ) { return true; }
				if ( details.re ) {
					return this.RegExp_test.call(details.re, haystack) === details.expect;
				}
				return haystack.includes(details.pattern) === details.expect;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function proxyApplyFn(
		target = '',
		handler = ''
	) {
		let context = self;
		let prop = target;
		for (;;) {
			const pos = prop.indexOf('.');
			if ( pos === -1 ) { break; }
			context = context[prop.slice(0, pos)];
			if ( context instanceof Object === false ) { return; }
			prop = prop.slice(pos+1);
		}
		const fn = context[prop];
		if ( typeof fn !== 'function' ) { return; }
		if ( fn.prototype && fn.prototype.constructor === fn ) {
			context[prop] = new Proxy(fn, { construct: handler });
			return (...args) => { return Reflect.construct(...args); };
		}
		context[prop] = new Proxy(fn, { apply: handler });
		return (...args) => { return Reflect.apply(...args); };
	}
	function getExceptionToken() {
		const safe = safeSelf();
		const token =
			String.fromCharCode(Date.now() % 26 + 97) +
			safe.Math_floor(safe.Math_random() * 982451653 + 982451653).toString(36);
		const oe = self.onerror;
		self.onerror = function(msg, ...args) {
			if ( typeof msg === 'string' && msg.includes(token) ) { return true; }
			if ( oe instanceof Function ) {
				return oe.call(this, msg, ...args);
			}
		}.bind();
		return token;
	}
	function matchesStackTrace(
		needleDetails,
		logLevel = ''
	) {
		const safe = safeSelf();
		const log = console.log.bind(console);
		const exceptionToken = getExceptionToken();
		const error = new safe.Error(exceptionToken);
		const docURL = new URL(self.location.href);
		docURL.hash = '';
		// Normalize stack trace
		const reLine = /(.*?@)?(\S+)(:\d+):\d+\)?$/;
		const lines = [];
		for ( let line of error.stack.split(/[\n\r]+/) ) {
			if ( line.includes(exceptionToken) ) { continue; }
			line = line.trim();
			const match = safe.RegExp_exec.call(reLine, line);
			if ( match === null ) { continue; }
			let url = match[2];
			if ( url.startsWith('(') ) { url = url.slice(1); }
			if ( url === docURL.href ) {
				url = 'inlineScript';
			} else if ( url.startsWith('<anonymous>') ) {
				url = 'injectedScript';
			}
			let fn = match[1] !== undefined
				? match[1].slice(0, -1)
				: line.slice(0, match.index).trim();
			if ( fn.startsWith('at') ) { fn = fn.slice(2).trim(); }
			let rowcol = match[3];
			lines.push(' ' + `${fn} ${url}${rowcol}:1`.trim());
		}
		lines[0] = `stackDepth:${lines.length-1}`;
		const stack = lines.join('\t');
		const r = needleDetails.matchAll !== true &&
			safe.testPattern(needleDetails, stack);
		if (
			logLevel === 'all' ||
			logLevel === 'match' && r ||
			logLevel === 'nomatch' && !r
		) {
			log(stack.replace(/\t/g, '\n'));
		}
		return r;
	}
	function objectFindOwnerFn(
		root,
		path,
		prune = false
	) {
		let owner = root;
		let chain = path;
		for (;;) {
			if ( typeof owner !== 'object' || owner === null  ) { return false; }
			const pos = chain.indexOf('.');
			if ( pos === -1 ) {
				if ( prune === false ) {
					return owner.hasOwnProperty(chain);
				}
				let modified = false;
				if ( chain === '*' ) {
					for ( const key in owner ) {
						if ( owner.hasOwnProperty(key) === false ) { continue; }
						delete owner[key];
						modified = true;
					}
				} else if ( owner.hasOwnProperty(chain) ) {
					delete owner[chain];
					modified = true;
				}
				return modified;
			}
			const prop = chain.slice(0, pos);
			const next = chain.slice(pos + 1);
			let found = false;
			if ( prop === '[-]' && Array.isArray(owner) ) {
				let i = owner.length;
				while ( i-- ) {
					if ( objectFindOwnerFn(owner[i], next) === false ) { continue; }
					owner.splice(i, 1);
					found = true;
				}
				return found;
			}
			if ( prop === '{-}' && owner instanceof Object ) {
				for ( const key of Object.keys(owner) ) {
					if ( objectFindOwnerFn(owner[key], next) === false ) { continue; }
					delete owner[key];
					found = true;
				}
				return found;
			}
			if (
				prop === '[]' && Array.isArray(owner) ||
				prop === '{}' && owner instanceof Object ||
				prop === '*' && owner instanceof Object
			) {
				for ( const key of Object.keys(owner) ) {
					if (objectFindOwnerFn(owner[key], next, prune) === false ) { continue; }
					found = true;
				}
				return found;
			}
			if ( owner.hasOwnProperty(prop) === false ) { return false; }
			owner = owner[prop];
			chain = chain.slice(pos + 1);
		}
	}
	function objectPruneFn(
		obj,
		rawPrunePaths,
		rawNeedlePaths,
		stackNeedleDetails = { matchAll: true },
		extraArgs = {}
	) {
		if ( typeof rawPrunePaths !== 'string' ) { return; }
		const prunePaths = rawPrunePaths !== ''
			? rawPrunePaths.split(/ +/)
			: [];
		const needlePaths = prunePaths.length !== 0 && rawNeedlePaths !== ''
			? rawNeedlePaths.split(/ +/)
			: [];
		if ( stackNeedleDetails.matchAll !== true ) {
			if ( matchesStackTrace(stackNeedleDetails, extraArgs.logstack) === false ) {
				return;
			}
		}
		if ( objectPruneFn.mustProcess === undefined ) {
			objectPruneFn.mustProcess = (root, needlePaths) => {
				for ( const needlePath of needlePaths ) {
					if ( objectFindOwnerFn(root, needlePath) === false ) {
						return false;
					}
				}
				return true;
			};
		}
		if ( prunePaths.length === 0 ) { return; }
		let outcome = 'nomatch';
		if ( objectPruneFn.mustProcess(obj, needlePaths) ) {
			for ( const path of prunePaths ) {
				if ( objectFindOwnerFn(obj, path, true) ) {
					outcome = 'match';
				}
			}
		}
		if ( outcome === 'match' ) { return obj; }
	}
	if ( propChain === undefined || propChain === '' ) { return; }
	if ( rawPrunePaths === undefined ) { rawPrunePaths = ''; }
	if ( rawNeedlePaths === undefined ) { rawNeedlePaths = ''; }
	const safe = safeSelf();
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 3);
	const reflector = proxyApplyFn(propChain, function(...args) {
		const objBefore = reflector(...args);
		if ( objBefore instanceof Object === false ) { return objBefore; }
		const objAfter = objectPruneFn(
			objBefore,
			rawPrunePaths,
			rawNeedlePaths,
			{ matchAll: true },
			extraArgs
		);
		return objAfter || objBefore;
	});
}


trusted-replace-argument.js application/javascript
function(propChain, argpos, argraw) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Object_fromEntries': Object.fromEntries.bind(Object),
			'JSON': self.JSON,
			'JSON_parseFn': self.JSON.parse,
			'JSON_parse': (...args) => safe.JSON_parseFn.call(safe.JSON, ...args),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function validateConstantFn(raw) {
		const safe = safeSelf();
		const extraArgs = safe.getExtraArgs(Array.from(arguments), 1);
		let value;
		if ( raw === 'undefined' ) {
			value = undefined;
		} else if ( raw === 'false' ) {
			value = false;
		} else if ( raw === 'true' ) {
			value = true;
		} else if ( raw === 'null' ) {
			value = null;
		} else if ( raw === "''" || raw === '' ) {
			value = '';
		} else if ( raw === '[]' || raw === 'emptyArr' ) {
			value = [];
		} else if ( raw === '{}' || raw === 'emptyObj' ) {
			value = {};
		} else if ( raw === 'noopFunc' ) {
			value = function(){};
		} else if ( raw === 'trueFunc' ) {
			value = function(){ return true; };
		} else if ( raw === 'falseFunc' ) {
			value = function(){ return false; };
		} else if ( /^-?\d+$/.test(raw) ) {
			value = parseInt(raw);
			if ( isNaN(raw) ) { return; }
			if ( Math.abs(raw) > 0x7FFF ) { return; }
		} else {
			if ( raw.startsWith('{') && raw.endsWith('}') ) {
				try { value = safe.JSON_parse(raw).value; } catch(ex) { return; }
			}
		}
		if ( extraArgs.as !== undefined ) {
			if ( extraArgs.as === 'function' ) {
				return ( ) => value;
			} else if ( extraArgs.as === 'callback' ) {
				return ( ) => (( ) => value);
			} else if ( extraArgs.as === 'resolved' ) {
				return Promise.resolve(value);
			} else if ( extraArgs.as === 'rejected' ) {
				return Promise.reject(value);
			}
		}
		return value;
	}
	function proxyApplyFn(
		target = '',
		handler = ''
	) {
		let context = self;
		let prop = target;
		for (;;) {
			const pos = prop.indexOf('.');
			if ( pos === -1 ) { break; }
			context = context[prop.slice(0, pos)];
			if ( context instanceof Object === false ) { return; }
			prop = prop.slice(pos+1);
		}
		const fn = context[prop];
		if ( typeof fn !== 'function' ) { return; }
		if ( fn.prototype && fn.prototype.constructor === fn ) {
			context[prop] = new Proxy(fn, { construct: handler });
			return (...args) => { return Reflect.construct(...args); };
		}
		context[prop] = new Proxy(fn, { apply: handler });
		return (...args) => { return Reflect.apply(...args); };
	}
	if ( propChain === undefined || propChain === '' ) { return; }
	if ( argpos === undefined || argpos === '' ) { return; }
	if ( argraw === undefined || argraw === '' ) { return; }
	const safe = safeSelf();
	const log = console.log.bind(console, makeLogPrefix('trusted-replace-argument', propChain, argpos, argraw));
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 3);
	const normalValue = validateConstantFn(argraw);
	const reCondition = extraArgs.condition
		? safe.patternToRegex(extraArgs.condition)
		: /^/;
	const reflector = proxyApplyFn(propChain, function(...args) {
		const arglist = args[args.length-1];
		if ( Array.isArray(arglist) === false ) { return reflector(...args); }
		const argBefore = arglist[argpos];
		if ( reCondition.test(argBefore) === false ) { return reflector(...args); }
		arglist[argpos] = normalValue;
		log(`Replaced argument:\nBefore: ${JSON.stringify(argBefore)}\nAfter: ${normalValue}`);
		return reflector(...args);
	});
}


trusted-replace-outbound-text.js
function(propChain, pattern, replacement) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Object_fromEntries': Object.fromEntries.bind(Object),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	function makeLogPrefix(...args) {
		return `uBO: [${args.join(' \u205D ')}]` || '';
	}
	function proxyApplyFn(
		target = '',
		handler = ''
	) {
		let context = self;
		let prop = target;
		for (;;) {
			const pos = prop.indexOf('.');
			if ( pos === -1 ) { break; }
			context = context[prop.slice(0, pos)];
			if ( context instanceof Object === false ) { return; }
			prop = prop.slice(pos+1);
		}
		const fn = context[prop];
		if ( typeof fn !== 'function' ) { return; }
		if ( fn.prototype && fn.prototype.constructor === fn ) {
			context[prop] = new Proxy(fn, { construct: handler });
			return (...args) => { return Reflect.construct(...args); };
		}
		context[prop] = new Proxy(fn, { apply: handler });
		return (...args) => { return Reflect.apply(...args); };
	}
	if ( propChain === undefined || propChain === '' ) { return; }
	if ( pattern === undefined ) { pattern = ''; }
	if ( replacement === undefined ) { replacement = ''; }
	const safe = safeSelf();
	const log = console.log.bind(console, makeLogPrefix('trusted-replace-outbound-text', ...arguments));
	const rePattern = safe.patternToRegex(pattern);
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 3);
	const reCondition = safe.patternToRegex(extraArgs.condition || '');
	const reflector = proxyApplyFn(propChain, function(...args) {
		const textBefore = reflector(...args);
		if ( pattern === '' ) {
			log('Outbound text:\n', textBefore);
			return textBefore;
		}
		reCondition.lastIndex = 0;
		if ( reCondition.test(textBefore) === false ) { return textBefore; }
		const textAfter = textBefore.replace(rePattern, replacement);
		if ( textAfter === textBefore ) { return textBefore; }
		log('Matched and replaced');
		if ( extraArgs.scripletLogLevel > 1 ) {
			log('Modified outbound text:\n', textAfter);
		}
		return textAfter;
	});
}


# https://github.com/gorhill/uBlock/commit/1de0e820b87fdd3717b9f2653baaa7a934075055
no-requestAnimationFrame-if.js application/javascript
alias norafif.js
alias prevent-requestAnimationFrame.js
function(needle) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Function_toStringFn': self.Function.prototype.toString,
			'Function_toString': thisArg => safe.Function_toStringFn.call(thisArg),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	if ( needle === undefined ) { needle = ''; }
	const needleNot = needle.charAt(0) === '!';
	if ( needleNot ) { needle = needle.slice(1); }
	const safe = safeSelf();
	const log = needleNot === false && needle === '' ? console.log.bind(console, 'uBO:') : undefined;
	const reNeedle = safe.patternToRegex(needle);
	window.requestAnimationFrame = new Proxy(window.requestAnimationFrame, {
		apply: function(target, thisArg, args) {
			const a = args[0] instanceof Function
				? String(safe.Function_toString(args[0]))
				: String(args[0]);
			let defuse = false;
			if ( log !== undefined ) {
				log('requestAnimationFrame("%s")', a);
			} else {
				defuse = reNeedle.test(a) !== needleNot;
			}
			if ( defuse ) {
				args[0] = function(){};
			}
			return target.apply(thisArg, args);
		}
	});
}


# https://github.com/uBlockOrigin/uAssets/issues/2912
# Reference:
# https://github.com/fingerprintjs/fingerprintjs/tree/v2
fingerprint2.js application/javascript
(function() {
	'use strict';
	const hex32 = len => {
		return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)
			.toString(16)
			.slice(-len)
			.padStart(len, '0');
	};
	const browserId = `${hex32(8)}${hex32(8)}${hex32(8)}${hex32(8)}`;
	const fp2 = function(){};
	fp2.get = function(opts, cb) {
		if ( !cb  ) { cb = opts; }
		setTimeout(( ) => { cb([]); }, 1);
	};
	fp2.getPromise = function() {
		return Promise.resolve([]);
	};
	fp2.getV18 = function() {
		return browserId;
	};
	fp2.x64hash128 = function() {
		return browserId;
	};
	fp2.prototype = {
		get: function(opts, cb) {
			if ( !cb  ) { cb = opts; }
			setTimeout(( ) => { cb(browserId, []); }, 1);
		},
	};
	self.Fingerprint2 = fp2;
})();


fingerprint3.js application/javascript
(function() {
	'use strict';
	const visitorId = (( ) => {
		let id = '';
		for ( let i = 0; i < 8; i++ ) {
			id += (Math.random() * 0x10000 + 0x1000 | 0).toString(16).slice(-4);
		}
		return id;
	})();
	const FingerprintJS = class {
		static hashComponents() {
			return visitorId;
		}
		static load() {
			return Promise.resolve(new FingerprintJS());
		}
		get() {
			return Promise.resolve({
				visitorId,
			});
		}
	};
	window.FingerprintJS = FingerprintJS;
})();


# https://github.com/NanoAdblocker/NanoFilters/issues/149
remove-cookie.js application/javascript
alias cookie-remover.js
function(needle) {
	'use strict';
	const scriptletGlobals = {};
	function safeSelf() {
		if ( scriptletGlobals.safeSelf ) {
			return scriptletGlobals.safeSelf;
		}
		const self = window;
		const safe = {
			'Object_fromEntries': Object.fromEntries.bind(Object),
			escapeRegexChars(s) {
				return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			},
			patternToRegex(pattern, flags = undefined, verbatim = false) {
				if ( pattern === '' ) { return /^/; }
				const match = /^\/(.+)\/([gimsu]*)$/.exec(pattern);
				if ( match === null ) {
					const reStr = this.escapeRegexChars(pattern);
					return new RegExp(verbatim ? `^${reStr}$` : reStr, flags);
				}
				try {
					return new RegExp(match[1], match[2] || undefined);
				}
				catch(ex) {
				}
				return /^/;
			},
			getExtraArgs(args, offset = 0) {
				const entries = args.slice(offset).reduce((out, v, i, a) => {
					if ( (i & 1) === 0 ) {
						const rawValue = a[i+1];
						const value = /^\d+$/.test(rawValue)
							? parseInt(rawValue, 10)
							: rawValue;
						out.push([ a[i], value ]);
					}
					return out;
				}, []);
				return this.Object_fromEntries(entries);
			},
		};
		scriptletGlobals.safeSelf = safe;
		return safe;
	}
	if ( needle === undefined ) { needle = ''; }
	const safe = safeSelf();
	const reName = safe.patternToRegex(needle);
	const extraArgs = safe.getExtraArgs(Array.from(arguments), 1);
	const throttle = (fn, ms = 500) => {
		if ( throttle.timer !== undefined ) { return; }
		throttle.timer = setTimeout(( ) => {
			throttle.timer = undefined;
			fn();
		}, ms);
	};
	const removeCookie = ( ) => {
		document.cookie.split(';').forEach(cookieStr => {
			const pos = cookieStr.indexOf('=');
			if ( pos === -1 ) { return; }
			const cookieName = cookieStr.slice(0, pos).trim();
			if ( reName.test(cookieName) === false ) { return; }
			const part1 = cookieName + '=';
			const part2a = '; domain=' + document.location.hostname;
			const part2b = '; domain=.' + document.location.hostname;
			let part2c, part2d;
			const domain = document.domain;
			if ( domain ) {
				if ( domain !== document.location.hostname ) {
					part2c = '; domain=.' + domain;
				}
				if ( domain.startsWith('www.') ) {
					part2d = '; domain=' + domain.replace('www', '');
				}
			}
			const part3 = '; path=/';
			const part4 = '; Max-Age=-1000; expires=Thu, 01 Jan 1970 00:00:00 GMT';
			document.cookie = part1 + part4;
			document.cookie = part1 + part2a + part4;
			document.cookie = part1 + part2b + part4;
			document.cookie = part1 + part3 + part4;
			document.cookie = part1 + part2a + part3 + part4;
			document.cookie = part1 + part2b + part3 + part4;
			if ( part2c !== undefined ) {
				document.cookie = part1 + part2c + part3 + part4;
			}
			if ( part2d !== undefined ) {
				document.cookie = part1 + part2d + part3 + part4;
			}
		});
	};
	removeCookie();
	window.addEventListener('beforeunload', removeCookie);
	if ( typeof extraArgs.when !== 'string' ) { return; }
	const supportedEventTypes = [ 'scroll', 'keydown' ];
	const eventTypes = extraArgs.when.split(/\s/);
	for ( const type of eventTypes ) {
		if ( supportedEventTypes.includes(type) === false ) { continue; }
		document.addEventListener(type, ( ) => {
			throttle(removeCookie);
		}, { passive: true });
	}
}


# https://www.reddit.com/r/firefox/comments/9dudod/the_mysterious_case_of_missing_urls_and_googles/e5kgkkh
ampproject_v0.js application/javascript
alias ampproject.org/v0.js
(function() {
	'use strict';
	const head = document.head;
	if ( !head ) { return; }
	const style = document.createElement('style');
	style.textContent = [
		'body {',
		'  animation: none !important;',
		'  overflow: unset !important;',
		'}'
	].join('\n');
	head.appendChild(style);
})();


# https://github.com/gorhill/uBlock/commit/f842ab6d3c1cf0394f95d27092bf59627262da40
# https://www.reddit.com/r/uBlockOrigin/comments/ghjqph/
# https://github.com/NanoMeow/QuickReports/issues/3717
amazon_apstag.js application/javascript
(function() {
	'use strict';
	const noopfn = function() {
		; // jshint ignore:line
	}.bind();
	const apstag = {
		fetchBids: function(a, b) {
			if ( b instanceof Function ) {
				b([]);
			}
		},
		init: noopfn,
		setDisplayBids: noopfn,
		targetingKeys: noopfn,
	};
	window.apstag = apstag;
})();


multiup.js application/javascript
(function() {
	'use strict';
	const handler = ev => {
		const target = ev.target;
		if ( target.matches('button[link]') === false ) { return; }
		const ancestor = target.closest('form');
		if ( ancestor === null ) { return; }
		if ( ancestor !== target.parentElement ) { return; }
		const link = (target.getAttribute('link') || '').trim();
		if ( link === '' ) { return; }
		ev.preventDefault();
		ev.stopPropagation();
		document.location.href = link;
	};
	document.addEventListener('click', handler, { capture: true });
})();
